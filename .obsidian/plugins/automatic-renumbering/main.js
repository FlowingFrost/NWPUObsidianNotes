/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AutoReordering
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/pasteAndDropHandler.ts
var import_obsidian = require("obsidian");

// src/SettingsManager.ts
var DEFAULT_RENUMBERING_SETTINGS = {
  liveUpdate: true,
  smartPasting: true,
  startsFromOne: true
};
var DEFAULT_CHECKLIST_SETTINGS = {
  liveUpdate: true,
  checkedItemsAtBottom: true,
  sortSpecialChars: true,
  charsToDelete: ""
};
var DEFAULT_SETTINGS = {
  renumbering: DEFAULT_RENUMBERING_SETTINGS,
  checklist: DEFAULT_CHECKLIST_SETTINGS,
  indentSize: 4
};
var SettingsManager = class _SettingsManager {
  constructor() {
    this.settings = DEFAULT_SETTINGS;
  }
  static getInstance() {
    if (!_SettingsManager.instance) {
      _SettingsManager.instance = new _SettingsManager();
    }
    return _SettingsManager.instance;
  }
  getSettings() {
    return this.settings;
  }
  setSettings(settings) {
    this.settings = settings;
  }
  getLiveNumberingUpdate() {
    return this.settings.renumbering.liveUpdate;
  }
  setLiveNumberingUpdate(value) {
    this.settings.renumbering.liveUpdate = value;
  }
  getSmartPasting() {
    return this.settings.renumbering.smartPasting;
  }
  setSmartPasting(value) {
    this.settings.renumbering.smartPasting = value;
  }
  getStartsFromOne() {
    return this.settings.renumbering.startsFromOne;
  }
  setStartsFromOne(value) {
    this.settings.renumbering.startsFromOne = value;
  }
  getIndentSize() {
    return this.settings.indentSize;
  }
  setIndentSize(value) {
    this.settings.indentSize = value;
  }
  getLiveCheckboxUpdate() {
    return this.settings.checklist.liveUpdate;
  }
  setLiveCheckboxUpdate(value) {
    this.settings.checklist.liveUpdate = value;
  }
  isCheckedItemsAtBottom() {
    return this.settings.checklist.checkedItemsAtBottom;
  }
  setCheckedItemsAtBottom(value) {
    this.settings.checklist.checkedItemsAtBottom = value;
  }
  getCharsToDelete() {
    return this.settings.checklist.charsToDelete;
  }
  setCharsToDelete(value) {
    this.settings.checklist.charsToDelete = value;
  }
  getSortSpecialChars() {
    return this.settings.checklist.sortSpecialChars;
  }
  setSortSpecialChars(value) {
    this.settings.checklist.sortSpecialChars = value;
  }
};

// src/utils.ts
function getLineInfo(line) {
  const length = line.length;
  let offset = 0;
  let numOfSpaceIndents = 0;
  const indentSize = SettingsManager.getInstance().getIndentSize();
  while (offset < length && (line[offset] === " " || line[offset] === "	")) {
    numOfSpaceIndents += line[offset] === " " ? 1 : indentSize;
    offset++;
  }
  const spaceCharsNum = offset;
  while (offset < length && "0".charCodeAt(0) <= line.charCodeAt(offset) && line.charCodeAt(offset) <= "9".charCodeAt(0)) {
    offset++;
  }
  const isNumberDetected = spaceCharsNum !== offset && line[offset] === "." && line[offset + 1] === " ";
  let number = void 0;
  if (!isNumberDetected) {
    offset = spaceCharsNum;
  } else {
    const parsedNum = parseInt(line.slice(spaceCharsNum, offset));
    if (isNaN(parsedNum)) {
      offset = spaceCharsNum;
    } else {
      number = parsedNum;
      offset += 2;
    }
  }
  const checkboxChar = getCheckboxInfo(line, offset, isNumberDetected);
  return {
    spaceCharsNum,
    spaceIndent: numOfSpaceIndents,
    number,
    textOffset: offset,
    checkboxChar
  };
}
function getCheckboxInfo(line, index, isNumberDetected) {
  const NUMBERED_CHECKBOX = /^\s*\[(.)\] /;
  const UNNUMBERED_CHECKBOX = /^\s*- \[(.)\] /;
  const pattern = isNumberDetected ? NUMBERED_CHECKBOX : UNNUMBERED_CHECKBOX;
  const stringToCheck = isNumberDetected ? line.slice(index) : line;
  const match = stringToCheck.match(pattern);
  if (match) {
    return match[1];
  }
  return void 0;
}
function getListStart(editor, currLineIndex) {
  if (currLineIndex < 0 || editor.lastLine() < currLineIndex) {
    return void 0;
  }
  const currInfo = getLineInfo(editor.getLine(currLineIndex));
  if (currInfo.number === void 0) {
    return currLineIndex;
  }
  let prevIndex = currLineIndex - 1;
  while (0 <= prevIndex && getLineInfo(editor.getLine(prevIndex)).number !== void 0) {
    prevIndex--;
  }
  return prevIndex + 1;
}
function getPrevItemIndex(editor, index) {
  if (index <= 0 || editor.lastLine() < index) {
    return void 0;
  }
  const currSpaceOffset = getLineInfo(editor.getLine(index)).spaceIndent;
  for (let prevIndex = index - 1; prevIndex >= 0; prevIndex--) {
    const info = getLineInfo(editor.getLine(prevIndex));
    if (info.spaceIndent > currSpaceOffset) {
      continue;
    }
    if (info.spaceIndent === currSpaceOffset && info.number !== void 0) {
      return prevIndex;
    }
    return void 0;
  }
  return void 0;
}
function findFirstNumbersAfterIndex(editor, startIndex) {
  const result = [];
  const currentLineInfo = getLineInfo(editor.getLine(startIndex));
  if (!currentLineInfo || currentLineInfo.spaceIndent === void 0) {
    return [];
  }
  let maxIndentToTrack = Infinity;
  for (let i = startIndex; i <= editor.lastLine(); i++) {
    const line = editor.getLine(i);
    const info = getLineInfo(line);
    if (info.spaceIndent === void 0) {
      continue;
    }
    const currentIndent = info.spaceIndent;
    if (currentIndent > maxIndentToTrack) {
      continue;
    }
    if (info.number === void 0) {
      continue;
    }
    if (result[currentIndent] === void 0) {
      result[currentIndent] = info.number;
    }
    if (currentIndent < maxIndentToTrack) {
      maxIndentToTrack = currentIndent;
    }
    if (currentIndent === 0 && result[0] !== void 0) {
      break;
    }
  }
  return result;
}
function findFirstNumbersByIndentFromEnd(lines) {
  const result = [];
  let maxIndentToTrack = Infinity;
  for (let i = lines.length - 1; i >= 0; i--) {
    const line = lines[i];
    const info = getLineInfo(line);
    if (!info || info.spaceIndent === void 0) {
      continue;
    }
    const currentIndent = info.spaceIndent;
    if (currentIndent > maxIndentToTrack) {
      continue;
    }
    maxIndentToTrack = currentIndent;
    if (info.number === void 0) {
      if (currentIndent === 0) {
        break;
      }
      continue;
    }
    result[currentIndent] = i;
  }
  return result;
}

// src/pasteAndDropHandler.ts
function handlePaste(evt, editor) {
  var _a, _b;
  const updateNumbering = SettingsManager.getInstance().getLiveNumberingUpdate();
  const updateChecklist = SettingsManager.getInstance().getLiveCheckboxUpdate();
  if (!updateNumbering && !updateChecklist) {
    return { start: void 0, end: void 0 };
  }
  const content = (_a = evt.clipboardData) == null ? void 0 : _a.getData("text");
  if (evt.defaultPrevented || !content) {
    return { start: void 0, end: void 0 };
  }
  evt.preventDefault();
  const { anchor, head } = editor.listSelections()[0];
  const baseIndex = Math.min(anchor.line, head.line);
  let modifiedContent = content;
  const smartPasting = SettingsManager.getInstance().getSmartPasting();
  if (smartPasting) {
    const indexAfterPasting = Math.max(anchor.line, head.line) + 1;
    modifiedContent = (_b = modifyText(editor, content, indexAfterPasting)) != null ? _b : content;
  }
  editor.replaceSelection(modifiedContent);
  const contentLines = modifiedContent.split("\n");
  const numOfLines = contentLines.length - 1;
  const start = baseIndex;
  const end = start + numOfLines;
  return { start, end };
}
function handleDrop(evt, editor) {
  var _a, _b;
  const settingsManager = SettingsManager.getInstance();
  if (!settingsManager.getLiveNumberingUpdate() && !settingsManager.getLiveCheckboxUpdate()) {
    return { start: void 0, end: void 0 };
  }
  const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
  if (!activeView || !activeView.editor.hasFocus()) {
    return { start: void 0, end: void 0 };
  }
  const editorView = activeView.editor.cm;
  const dropPosition = editorView.posAtCoords({ x: evt.clientX, y: evt.clientY });
  if (dropPosition === null) {
    return { start: void 0, end: void 0 };
  }
  const content = (_a = evt.dataTransfer) == null ? void 0 : _a.getData("text");
  if (evt.defaultPrevented || !content) {
    return { start: void 0, end: void 0 };
  }
  evt.preventDefault();
  const pos = editor.offsetToPos(dropPosition);
  const { anchor, head } = editor.listSelections()[0];
  let modifiedContent = content;
  const smartPasting = SettingsManager.getInstance().getSmartPasting();
  if (smartPasting) {
    modifiedContent = (_b = modifyText(editor, content, pos.line)) != null ? _b : content;
  }
  const selectionFrom = anchor.line < head.line || anchor.line === head.line && anchor.ch < head.ch ? anchor : head;
  const selectionTo = anchor.line > head.line || anchor.line === head.line && anchor.ch > head.ch ? anchor : head;
  const transaction = {
    changes: [
      {
        from: selectionFrom,
        to: selectionTo,
        text: ""
      },
      {
        from: pos,
        to: pos,
        text: modifiedContent
      }
    ]
  };
  editor.transaction(transaction);
  const lines = modifiedContent.split("\n");
  const endPos = {
    line: pos.line + lines.length - 1,
    ch: lines.length > 1 ? lines[lines.length - 1].length : pos.ch + modifiedContent.length
  };
  const start = Math.min(pos.line, selectionFrom.line);
  const end = Math.max(endPos.line, selectionTo.line) + 1;
  return { start, end };
}
function modifyText(editor, pastedText, pastePosition) {
  const currentLineInfo = getLineInfo(editor.getLine(pastePosition));
  if (!currentLineInfo.number) {
    return;
  }
  const pastedLines = pastedText.split("\n");
  const sourceListNumbers = findFirstNumbersByIndentFromEnd(pastedLines);
  const targetListNumbers = findFirstNumbersAfterIndex(editor, pastePosition);
  for (let indentLevel = 0; indentLevel < sourceListNumbers.length; indentLevel++) {
    const sourceLineIndex = sourceListNumbers[indentLevel];
    const newNumber = targetListNumbers[indentLevel];
    if (sourceLineIndex === void 0 || newNumber === void 0) {
      continue;
    }
    const sourceLine = pastedLines[sourceLineIndex];
    const sourceLineInfo = getLineInfo(sourceLine);
    pastedLines[sourceLineIndex] = sourceLine.slice(0, sourceLineInfo.spaceCharsNum) + newNumber + ". " + sourceLine.slice(sourceLineInfo.textOffset);
  }
  const renumberedText = pastedLines.join("\n");
  return renumberedText;
}

// src/command-registration.ts
var import_obsidian2 = require("obsidian");

// src/checkbox.ts
function reorderChecklist(editor, start, limit) {
  const result = limit === void 0 ? reorderAtIndex(editor, start) : reorderAllListsInRange(editor, start, limit);
  if (!result) {
    return void 0;
  }
  const { changes, reorderResult } = result;
  applyChangesToEditor(editor, changes);
  return reorderResult;
}
function reorderAllListsInRange(editor, start, limit) {
  const isInvalidRange = start < 0 || editor.lastLine() + 1 < limit || limit < start;
  const changes = [];
  let i = start;
  let currentStart = void 0;
  let end = i;
  if (isInvalidRange) {
    console.error(
      `reorderAllListsInRange is invalid with index=${start}, limit=${limit}. editor.lastLine()=${editor.lastLine()}`
    );
    return;
  }
  for (; i < limit; i++) {
    const reorderData = reorderAtIndex(editor, i);
    if (reorderData === void 0 || reorderData.changes === void 0) {
      continue;
    }
    changes.push(...reorderData.changes);
    if (currentStart === void 0) {
      currentStart = reorderData.reorderResult.start;
    }
    end = reorderData.reorderResult.limit;
    i = end;
    while (shouldBeSortedAsChecked(getLineInfo(editor.getLine(i)).checkboxChar) !== void 0) {
      i++;
    }
  }
  if (changes.length === 0) return void 0;
  return {
    reorderResult: {
      start: currentStart != null ? currentStart : start,
      limit: end
    },
    changes
  };
}
function reorderAtIndex(editor, index) {
  const line = editor.getLine(index);
  const startInfo = getLineInfo(line);
  const hasContent = hasCheckboxContent(line);
  if (shouldBeSortedAsChecked(startInfo.checkboxChar) === void 0 || hasContent === false) {
    return;
  }
  const checklistStartIndex = getChecklistStart(editor, index);
  const { orderedItems, reorderResult } = reorder(editor, checklistStartIndex, startInfo);
  if (orderedItems.length === 0) {
    return;
  }
  const { start: startIndex, limit: endIndex } = reorderResult;
  const newText = endIndex > editor.lastLine() ? orderedItems.join("\n") : orderedItems.join("\n") + "\n";
  const change = {
    from: { line: startIndex, ch: 0 },
    to: { line: endIndex, ch: 0 },
    text: newText
  };
  return {
    changes: [change],
    reorderResult: {
      start: startIndex,
      limit: endIndex
    }
  };
}
function reorder(editor, index, startInfo) {
  const checkedItemsAtBottom = SettingsManager.getInstance().isCheckedItemsAtBottom();
  const uncheckedItems = [];
  const checkedMap = /* @__PURE__ */ new Map();
  const startIndex = findReorderStartPosition(editor, index, startInfo, checkedItemsAtBottom);
  let prevChar = "";
  let transitionIndex = 0;
  let i = startIndex;
  while (i <= editor.lastLine()) {
    const line = editor.getLine(i);
    const currInfo = getLineInfo(line);
    if (!isSameStatus(startInfo, currInfo)) {
      break;
    }
    const currentChar = currInfo.checkboxChar;
    if (currentChar === void 0) {
      break;
    }
    if (currentChar !== prevChar) {
      prevChar = currentChar;
      transitionIndex = uncheckedItems.length;
    }
    if (shouldBeSortedAsChecked(currentChar)) {
      if (!checkedMap.has(currentChar)) {
        checkedMap.set(currentChar, []);
      }
      checkedMap.get(currentChar).push([line, currInfo]);
    } else {
      uncheckedItems.push(line);
    }
    i++;
  }
  const finishedAt = i;
  const charsToDelete = getCharsToDelete();
  const checkedItems = [];
  const checkedItemsDel = [];
  const keys = Array.from(checkedMap.keys()).sort();
  const KVpairs = keys.flatMap((k) => checkedMap.get(k));
  for (const [s, lineInfo] of KVpairs) {
    if (!lineInfo.checkboxChar) {
      continue;
    }
    if (charsToDelete.has(lineInfo.checkboxChar)) {
      checkedItemsDel.push(s);
    } else if (shouldBeSortedAsChecked(lineInfo.checkboxChar)) {
      checkedItems.push(s);
    }
  }
  checkedItems.push(...checkedItemsDel);
  if (!checkedItemsAtBottom) {
    uncheckedItems.splice(transitionIndex);
  }
  const orderedItems = checkedItemsAtBottom ? [...uncheckedItems, ...checkedItems] : [...checkedItems, ...uncheckedItems];
  let count = 0;
  for (; count < orderedItems.length; count++) {
    if (orderedItems[count] !== editor.getLine(startIndex + count)) {
      break;
    }
  }
  orderedItems.splice(0, count);
  const newStart = startIndex + count;
  const offsettedStart = finishedAt - (orderedItems.length - 1) - 1;
  for (let i2 = orderedItems.length - 1; i2 >= 0; i2--) {
    if (orderedItems[i2] !== editor.getLine(offsettedStart + i2)) {
      orderedItems.splice(i2 + 1);
      break;
    }
  }
  return {
    orderedItems,
    reorderResult: {
      start: newStart,
      limit: newStart + orderedItems.length
    }
  };
}
function getChecklistStart(editor, index) {
  if (index === 0) {
    return index;
  }
  const startInfo = getLineInfo(editor.getLine(index));
  let i = index - 1;
  while (0 <= i) {
    const currInfo = getLineInfo(editor.getLine(i));
    if (!isSameStatus(startInfo, currInfo)) {
      break;
    }
    i--;
  }
  return i + 1;
}
function findReorderStartPosition(editor, startIndex, startInfo, checkedItemsAtBottom) {
  if (!checkedItemsAtBottom) {
    return startIndex;
  }
  let i = startIndex;
  while (i <= editor.lastLine()) {
    const currInfo = getLineInfo(editor.getLine(i));
    if (shouldBeSortedAsChecked(currInfo.checkboxChar) !== false || !isSameStatus(startInfo, currInfo)) {
      break;
    }
    i++;
  }
  return i;
}
function isSameStatus(info1, info2) {
  const hasSameNumberStatus = info1.number !== void 0 === (info2.number !== void 0);
  const hasSameIndentation = info1.spaceIndent === info2.spaceIndent;
  const hasSameCheckboxStatus = shouldBeSortedAsChecked(info1.checkboxChar) !== void 0 === (shouldBeSortedAsChecked(info2.checkboxChar) !== void 0);
  if (hasSameNumberStatus && hasSameIndentation && hasSameCheckboxStatus) {
    return true;
  }
  return false;
}
function deleteChecked(editor) {
  const lastLine = editor.lastLine();
  const changes = [];
  const charsToDelete = getCharsToDelete();
  let deletedItemCount = 0;
  let start = 0;
  let end = 0;
  for (let i = 0; i <= lastLine; i++) {
    const currLine = getLineInfo(editor.getLine(i));
    if (currLine.checkboxChar !== void 0 && charsToDelete.has(currLine.checkboxChar.toLowerCase())) {
      if (start === 0) {
        start = i;
      }
      changes.push({
        from: { line: i, ch: 0 },
        to: { line: i + 1, ch: 0 },
        text: ""
      });
      end = i;
      deletedItemCount++;
    }
  }
  applyChangesToEditor(editor, changes);
  if (end === lastLine && end !== 0) {
    const lastIndex = editor.lastLine();
    if (lastIndex > 0) {
      editor.replaceRange(
        "",
        { line: lastIndex - 1, ch: editor.getLine(lastIndex - 1).length },
        { line: lastIndex, ch: 0 }
      );
    }
  }
  const limit = end + 1 - deletedItemCount;
  return { deleteResult: { start, limit }, deletedItemCount };
}
function shouldBeSortedAsChecked(char) {
  if (char === void 0) {
    return void 0;
  }
  const sortSpecialChars = SettingsManager.getInstance().getSortSpecialChars();
  const checkedItems = getCharsToDelete();
  const isSpecialChar = char !== " ";
  if (isSpecialChar && sortSpecialChars || checkedItems.has(char)) {
    return true;
  }
  return false;
}
function getCharsToDelete() {
  const value = SettingsManager.getInstance().getCharsToDelete();
  const defaultDelete = ["x"];
  const filterChars = value.trim().toLowerCase().split(" ").filter((char) => char.length === 1);
  const charsToDelete = /* @__PURE__ */ new Set([...defaultDelete, ...filterChars]);
  return charsToDelete;
}
function hasCheckboxContent(line) {
  const CHECKBOX_WITH_CONTENT = /^(?:\s*\d+\.\s*\[.\]|\s*-\s*\[.\])\s+\S+/;
  return CHECKBOX_WITH_CONTENT.test(line);
}
function applyChangesToEditor(editor, changes) {
  if (changes.length > 0) {
    editor.transaction({ changes });
  }
}

// src/command-registration.ts
function registerCommands(plugin) {
  plugin.addCommand({
    id: "1-reneumber-selection",
    name: "Renumber lists: in selection or at cursor",
    editorCallback: (editor) => {
      const { anchor, head } = editor.listSelections()[0];
      const startLine = Math.min(anchor.line, head.line);
      const endLine = Math.max(anchor.line, head.line) + 1;
      plugin.getRenumberer().renumber(editor, startLine, endLine);
    }
  });
  plugin.addCommand({
    id: "2-renumber-entire-note",
    name: "Renumber lists: entire note",
    editorCallback: (editor) => {
      plugin.getRenumberer().renumber(editor, 0, editor.lastLine() + 1);
    }
  });
  plugin.addCommand({
    id: "3-checklist-at-cursor",
    name: "Reorder checkboxes: in selection or at cursor",
    editorCallback: (editor) => {
      const posToReturn = editor.getCursor();
      const renumberer = plugin.getRenumberer();
      const { anchor, head } = editor.listSelections()[0];
      const startLine = Math.min(anchor.line, head.line);
      const endLine = Math.max(anchor.line, head.line) + 1;
      const reorderResult = reorderChecklist(editor, startLine, endLine);
      if (SettingsManager.getInstance().getLiveNumberingUpdate() === true) {
        if (reorderResult !== void 0) {
          renumberer.renumber(editor, reorderResult.start, reorderResult.limit);
        }
      }
      plugin.updateCursorPosition(editor, posToReturn, reorderResult);
    }
  });
  plugin.addCommand({
    id: "4-checklist-entire-note",
    name: "Reorder checkboxes: entire note",
    editorCallback: (editor) => {
      const lineToReturn = editor.getCursor().line;
      const renumberer = plugin.getRenumberer();
      const reorderResult = reorderChecklist(editor, 0, editor.lastLine() + 1);
      if (SettingsManager.getInstance().getLiveNumberingUpdate() === true) {
        if (reorderResult !== void 0) {
          renumberer.renumber(editor, reorderResult.start, reorderResult.limit);
        }
      }
      editor.setCursor({ line: lineToReturn, ch: editor.getLine(lineToReturn).length });
    }
  });
  plugin.addCommand({
    id: "5-checklist-delete-checked-items",
    name: "Delete all checked Items in note",
    editorCallback: (editor) => {
      const lineToReturn = editor.getCursor().line;
      const renumberer = plugin.getRenumberer();
      const { deleteResult, deletedItemCount } = deleteChecked(editor);
      if (SettingsManager.getInstance().getLiveNumberingUpdate() === true) {
        renumberer.renumber(editor, deleteResult.start, deleteResult.limit);
      }
      const noticeString = deletedItemCount > 0 ? `Deleted ${deletedItemCount} lines` : "No checked items to delete";
      new import_obsidian2.Notice(noticeString);
      editor.setCursor({ line: lineToReturn, ch: editor.getLine(lineToReturn).length });
    }
  });
}

// src/Renumberer.ts
var Renumberer = class {
  constructor() {
    // renumbers all numbered lists in specified range
    this.renumberAllListsInRange = (editor, start, limit) => {
      const isInvalidRange = start < 0 || limit < start;
      const editorLastLine = editor.lastLine();
      const newChanges = [];
      if (isInvalidRange) {
        console.error(`Invalid renumbering range: start=${start}, limit=${limit}. Requires (0 <= start <= limit).`);
        return { changes: newChanges, endIndex: start };
      }
      if (editorLastLine + 1 < limit) {
        console.error(
          `Limit exceeds document bounds: attempted limit=${limit}, actual limit=${editorLastLine + 1}. Adjusting limit.`
        );
        limit = editorLastLine + 1;
      }
      let i = start;
      for (; i < limit; i++) {
        const line = editor.getLine(i);
        if (line === void 0) {
          continue;
        }
        const { number } = getLineInfo(line);
        if (number === void 0) {
          continue;
        }
        const startIndex = getListStart(editor, i);
        if (startIndex !== void 0) {
          const pendingChanges = this.renumberAtIndex(editor, startIndex, false);
          if (pendingChanges) {
            newChanges.push(...pendingChanges.changes);
            i = pendingChanges.endIndex;
          }
        }
      }
      return { changes: newChanges, endIndex: i };
    };
  }
  renumber(editor, start, limit) {
    let pendingChanges;
    if (limit === void 0 || limit === start) {
      pendingChanges = this.renumberAtIndex(editor, start);
    } else {
      pendingChanges = this.renumberAllListsInRange(editor, start, limit);
    }
    this.applyChangesToEditor(editor, pendingChanges.changes);
    return pendingChanges.endIndex;
  }
  // bfs where indents == junctions
  renumberAtIndex(editor, index, isLocal = true) {
    const changes = [];
    const queue = [index];
    let endIndex = index;
    if (index > 0) {
      queue.unshift(index - 1);
    }
    if (index < editor.lastLine()) {
      queue.push(index + 1);
    }
    const visited = [];
    const firstSpaceIndent = getLineInfo(editor.getLine(queue[0])).spaceIndent;
    visited[firstSpaceIndent] = queue[0];
    while (0 < queue.length) {
      const indexToRenumber = queue.shift();
      if (indexToRenumber > editor.lastLine()) {
        break;
      }
      const info = getLineInfo(editor.getLine(indexToRenumber));
      if (indexToRenumber < visited[info.spaceIndent]) {
        continue;
      }
      if (info.number === void 0) {
        continue;
      }
      const prevIndex = getPrevItemIndex(editor, indexToRenumber);
      const isStartFromOne = SettingsManager.getInstance().getStartsFromOne();
      let num;
      if (prevIndex === void 0) {
        num = isStartFromOne ? 1 : info.number;
      } else {
        num = getLineInfo(editor.getLine(prevIndex)).number + 1;
      }
      const changeResult = this.generateChanges(editor, indexToRenumber, num, info.spaceIndent, isLocal);
      changes.push(...changeResult.changes);
      queue.push(...changeResult.revisitIndices);
      visited[info.spaceIndent] = changeResult.endIndex;
      endIndex = Math.max(endIndex, changeResult.endIndex);
    }
    return { changes, endIndex };
  }
  // performs the calculation itself
  generateChanges(editor, firstIndex, currentNumber, firstIndent, isLocal = true) {
    const revisitIndices = [];
    const changes = [];
    let firstMatchInSuccession = true;
    if (firstIndex < 0) {
      return { changes, revisitIndices, endIndex: firstIndex };
    }
    let currentIndex = firstIndex;
    let indexToRevisit = true;
    for (; currentIndex <= editor.lastLine(); currentIndex++) {
      const lineText = editor.getLine(currentIndex);
      const info = getLineInfo(lineText);
      if (info.spaceIndent > firstIndent) {
        if (indexToRevisit) {
          revisitIndices.push(currentIndex);
          indexToRevisit = false;
        }
        continue;
      }
      if (info.spaceIndent < firstIndent) {
        revisitIndices.push(currentIndex);
        break;
      }
      indexToRevisit = true;
      if (info.number === void 0) {
        break;
      }
      if (info.number === currentNumber) {
        if (isLocal && firstMatchInSuccession === false) {
          currentIndex += 1;
          break;
        }
        firstMatchInSuccession = false;
        currentNumber++;
        continue;
      }
      firstMatchInSuccession = true;
      const updatedLine = this.getUpdatedLine(currentIndex, currentNumber, info, lineText);
      changes.push(updatedLine);
      currentNumber++;
    }
    return { changes, revisitIndices, endIndex: currentIndex };
  }
  getUpdatedLine(index, expectedNum, info, text) {
    const newText = `${text.slice(0, info.spaceCharsNum)}${expectedNum}. ${text.slice(info.textOffset)}`;
    const updatedLine = {
      from: { line: index, ch: 0 },
      to: { line: index, ch: text.length },
      text: newText
    };
    return updatedLine;
  }
  applyChangesToEditor(editor, changes) {
    if (changes.length > 0) {
      editor.transaction({ changes });
    }
  }
};

// src/settings-tab.ts
var import_obsidian3 = require("obsidian");
var AutoRenumberingSettings = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.settingsManager = SettingsManager.getInstance();
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const githubEl = createFragment();
    githubEl.appendText("For more information, visit ");
    githubEl.createEl("a", {
      href: "https://github.com/OmriLeviGit/Auto-List-Management-Obsidian",
      text: "Github"
    });
    githubEl.appendText(".");
    containerEl.appendChild(githubEl);
    new import_obsidian3.Setting(containerEl).setHeading();
    new import_obsidian3.Setting(containerEl).setName("Tab size").setDesc(
      "Set the indent size to the same size as in the editor's settings. Can be found under: Options > Editor > Tab indent size/Indent visual width."
    ).addSlider((slider) => {
      slider.setValue(this.settingsManager.getIndentSize()).setLimits(2, 8, 1).setDynamicTooltip().onChange(async (value) => {
        this.settingsManager.setIndentSize(value);
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setHeading().setName("Checklists");
    new import_obsidian3.Setting(containerEl).setName("Auto-sort on changes").setDesc("Automatically sort checklists whenever checkboxes are checked or unchecked.").addToggle(
      (toggle) => toggle.setValue(this.settingsManager.getLiveCheckboxUpdate()).onChange(async (value) => {
        this.settingsManager.setLiveCheckboxUpdate(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Place checked items at bottom").setDesc(
      "When enabled, checked tasks will be placed at the bottom. When disabled, they will be at the top."
    ).addToggle(
      (toggle) => toggle.setValue(this.settingsManager.isCheckedItemsAtBottom()).onChange(async (value) => {
        this.settingsManager.setCheckedItemsAtBottom(value);
        await this.plugin.saveSettings();
      })
    );
    const descEl = createFragment();
    descEl.appendText("When enabled, tasks with any special checkbox characters will be sorted according to ");
    descEl.createEl("a", {
      href: "https://en.wikipedia.org/wiki/ASCII",
      text: "ASCII"
    });
    descEl.appendText(". When disabled, only tasks marked for deletion will be sorted.");
    new import_obsidian3.Setting(containerEl).setName("Sort all special checkboxes").setDesc(descEl).addToggle(
      (toggle) => toggle.setValue(this.settingsManager.getSortSpecialChars()).onChange(async (value) => {
        this.settingsManager.setSortSpecialChars(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Checkbox delete-characters").setDesc(
      "Specify which checkbox characters mark tasks for deletion. Tasks with these characters are always sorted below tasks with other characters, and can be removed by using the delete command."
    ).addText((text) => {
      text.setPlaceholder("Enter characters").setValue(this.settingsManager.getCharsToDelete()).onChange(async (value) => {
        this.settingsManager.setCharsToDelete(value);
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("div", {
      text: "Enter single characters separated by spaces (case-insensitive). Default: 'X'.",
      cls: "setting-item-description"
    });
    containerEl.createEl("div", {
      text: "Example: '- /' means tasks with [x], [-], or [/] will be removed, while tasks with other characters like [>] will remain.",
      cls: "setting-item-description"
    });
    new import_obsidian3.Setting(containerEl).setHeading().setName("Numbered lists");
    new import_obsidian3.Setting(containerEl).setName("Auto-renumber on changes").setDesc("Automatically sort numbered lists as changes are made.").addToggle(
      (toggle) => toggle.setValue(this.settingsManager.getLiveNumberingUpdate()).onChange(async (value) => {
        this.settingsManager.setLiveNumberingUpdate(value);
        await this.plugin.saveSettings();
        if (value) {
          smartPastingToggleEl.classList.add("smart-paste-toggle");
          smartPastingToggleEl.classList.remove("smart-paste-toggle-disabled");
        } else {
          smartPastingToggleEl.classList.remove("smart-paste-toggle");
          smartPastingToggleEl.classList.add("smart-paste-toggle-disabled");
        }
      })
    );
    const smartPastingSetting = new import_obsidian3.Setting(containerEl).setName("Smart pasting").setDesc("Pasting keeps the sequencing consistent with the original numbered list.").addToggle(
      (toggle) => toggle.setValue(this.settingsManager.getSmartPasting()).onChange(async (value) => {
        this.settingsManager.setSmartPasting(value);
        await this.plugin.saveSettings();
      })
    );
    const smartPastingToggleEl = smartPastingSetting.settingEl;
    const isLiveNumberingUpdateEnabled = this.settingsManager.getLiveNumberingUpdate();
    if (isLiveNumberingUpdateEnabled) {
      smartPastingToggleEl.classList.add("smart-paste-toggle");
      smartPastingToggleEl.classList.remove("smart-paste-toggle-disabled");
    } else {
      smartPastingToggleEl.classList.add("smart-paste-toggle-disabled");
      smartPastingToggleEl.classList.remove("smart-paste-toggle");
    }
    new import_obsidian3.Setting(containerEl).setName("Start numbering from 1").setDesc("Whether lists always start from 1 or preserve their original starting numbers.").addToggle(
      (toggle) => toggle.setValue(this.settingsManager.getStartsFromOne()).onChange(async (value) => {
        this.settingsManager.setStartsFromOne(value);
        await this.plugin.saveSettings();
      })
    );
  }
};

// main.ts
var AutoReordering = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.blockChanges = false;
    this.checkboxClickedAt = void 0;
  }
  applyReordering(editor, start, end) {
    if (this.blockChanges) {
      return;
    }
    this.blockChanges = true;
    const posToReturn = editor.getCursor();
    let startIndex = start;
    let endIndex = end;
    let newLine;
    if (startIndex === void 0) {
      const result = this.getCurrIndex(editor);
      startIndex = result.index;
      newLine = result.mouseAt;
    }
    if (newLine !== void 0) {
      posToReturn.line = newLine;
    }
    let reorderResult;
    if (this.settingsManager.getLiveCheckboxUpdate() === true) {
      reorderResult = reorderChecklist(editor, startIndex, end);
    }
    if (this.settingsManager.getLiveNumberingUpdate() === true) {
      if (reorderResult !== void 0) {
        startIndex = reorderResult.start;
        endIndex = reorderResult.limit;
      }
      this.renumberer.renumber(editor, startIndex, endIndex);
    }
    this.updateCursorPosition(editor, posToReturn, reorderResult);
  }
  async onload() {
    await this.loadSettings();
    registerCommands(this);
    this.addSettingTab(new AutoRenumberingSettings(this.app, this));
    this.settingsManager = SettingsManager.getInstance();
    this.renumberer = new Renumberer();
    this.registerEvent(
      this.app.workspace.on("editor-change", (editor) => {
        setTimeout(() => {
          this.applyReordering(editor);
        });
      })
    );
    this.registerEvent(
      this.app.workspace.on("editor-paste", (evt, editor) => {
        const { start, end } = handlePaste.call(this, evt, editor);
        this.blockChanges = false;
        this.applyReordering(editor, start, end);
      })
    );
    this.registerEvent(
      this.app.workspace.on("editor-drop", (evt, editor) => {
        const { start, end } = handleDrop.call(this, evt, editor);
        this.blockChanges = false;
        this.applyReordering(editor, start, end);
      })
    );
    this.handleKeystrokeBound = this.handleKeystroke.bind(this);
    window.addEventListener("keydown", this.handleKeystrokeBound);
    this.handleMouseBound = this.handleMouseClick.bind(this);
    window.addEventListener("click", this.handleMouseBound);
  }
  handleKeystroke(event) {
    this.blockChanges = event.ctrlKey || event.metaKey || event.altKey;
  }
  //  mouse listener
  async handleMouseClick(event) {
    try {
      if (!this.settingsManager.getLiveCheckboxUpdate()) {
        return;
      }
      this.checkboxClickedAt = void 0;
      const target = event.target;
      if (target.matches('[type="checkbox"]')) {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
        if (activeView == null ? void 0 : activeView.editor.hasFocus()) {
          const editorView = activeView.editor.cm;
          const editor = activeView.editor;
          const pos = editorView.posAtCoords({ x: event.clientX, y: event.clientY });
          if (pos) {
            this.checkboxClickedAt = editor.offsetToPos(pos).line;
          }
        }
      }
    } catch (error) {
      console.error("Error in handleMouseClick:", error);
      this.checkboxClickedAt = void 0;
    } finally {
      this.blockChanges = false;
    }
  }
  async onunload() {
    window.removeEventListener("keydown", this.handleKeystrokeBound);
    window.removeEventListener("click", this.handleMouseBound);
  }
  async loadSettings() {
    const settingsManager = SettingsManager.getInstance();
    const settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    settingsManager.setSettings(settings);
  }
  async saveSettings() {
    const settingsManager = SettingsManager.getInstance();
    await this.saveData(settingsManager.getSettings());
  }
  getRenumberer() {
    return this.renumberer;
  }
  updateCursorPosition(editor, originalPos, reorderResult) {
    if (editor.somethingSelected() || !reorderResult) {
      return;
    }
    let newPosition;
    if (originalPos.line < reorderResult.start || reorderResult.limit <= originalPos.line) {
      newPosition = {
        line: originalPos.line,
        ch: originalPos.ch
      };
    } else {
      const line = editor.getLine(originalPos.line);
      newPosition = {
        line: originalPos.line,
        ch: line.length
        // not keeping the originalPos.ch bad ux on new lines after checked items
      };
    }
    editor.setCursor(newPosition);
  }
  getCurrIndex(editor) {
    const isInView = this.isCursorInView();
    if (this.checkboxClickedAt !== void 0) {
      const index = this.checkboxClickedAt;
      this.checkboxClickedAt = void 0;
      if (!isInView) {
        return { index, mouseAt: index };
      }
      return { index };
    }
    const selection = editor.listSelections()[0];
    return { index: Math.min(selection.anchor.line, selection.head.line) };
  }
  isCursorInView() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
    if (activeView) {
      const editorView = activeView.editor.cm;
      const pos = editorView.state.selection.main.head;
      const coords = editorView.coordsAtPos(pos);
      if (coords) {
        const editorRect = editorView.dom.getBoundingClientRect();
        return coords.top >= editorRect.top && coords.bottom <= editorRect.bottom;
      }
    }
    return true;
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibWFpbi50cyIsICJzcmMvcGFzdGVBbmREcm9wSGFuZGxlci50cyIsICJzcmMvU2V0dGluZ3NNYW5hZ2VyLnRzIiwgInNyYy91dGlscy50cyIsICJzcmMvY29tbWFuZC1yZWdpc3RyYXRpb24udHMiLCAic3JjL2NoZWNrYm94LnRzIiwgInNyYy9SZW51bWJlcmVyLnRzIiwgInNyYy9zZXR0aW5ncy10YWIudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImltcG9ydCB7IFBsdWdpbiwgRWRpdG9yLCBFZGl0b3JQb3NpdGlvbiwgTWFya2Rvd25WaWV3IH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBoYW5kbGVQYXN0ZSwgaGFuZGxlRHJvcCB9IGZyb20gXCJzcmMvcGFzdGVBbmREcm9wSGFuZGxlclwiO1xuaW1wb3J0IHsgcmVnaXN0ZXJDb21tYW5kcyB9IGZyb20gXCJzcmMvY29tbWFuZC1yZWdpc3RyYXRpb25cIjtcbmltcG9ydCBSZW51bWJlcmVyIGZyb20gXCJzcmMvUmVudW1iZXJlclwiO1xuaW1wb3J0IFBsdWdpblNldHRpbmdzIGZyb20gXCIuL3NyYy9zZXR0aW5ncy10YWJcIjtcbmltcG9ydCBTZXR0aW5nc01hbmFnZXIsIHsgREVGQVVMVF9TRVRUSU5HUyB9IGZyb20gXCJzcmMvU2V0dGluZ3NNYW5hZ2VyXCI7XG5pbXBvcnQgeyByZW9yZGVyQ2hlY2tsaXN0IH0gZnJvbSBcInNyYy9jaGVja2JveFwiO1xuaW1wb3J0IHsgUmVvcmRlclJlc3VsdCB9IGZyb20gXCJzcmMvdHlwZXNcIjtcbmltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tIFwiQGNvZGVtaXJyb3Ivdmlld1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRvUmVvcmRlcmluZyBleHRlbmRzIFBsdWdpbiB7XG4gICAgcHJpdmF0ZSByZW51bWJlcmVyOiBSZW51bWJlcmVyO1xuICAgIHByaXZhdGUgc2V0dGluZ3NNYW5hZ2VyOiBTZXR0aW5nc01hbmFnZXI7XG4gICAgcHJpdmF0ZSBibG9ja0NoYW5nZXMgPSBmYWxzZTtcbiAgICBwcml2YXRlIGNoZWNrYm94Q2xpY2tlZEF0OiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSBoYW5kbGVLZXlzdHJva2VCb3VuZDogKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB2b2lkO1xuICAgIHByaXZhdGUgaGFuZGxlTW91c2VCb3VuZDogKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB2b2lkO1xuXG4gICAgYXBwbHlSZW9yZGVyaW5nKGVkaXRvcjogRWRpdG9yLCBzdGFydD86IG51bWJlciwgZW5kPzogbnVtYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmJsb2NrQ2hhbmdlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmxvY2tDaGFuZ2VzID0gdHJ1ZTsgLy8gUHJldmVudHMgbXVsdGlwbGUgcmVudW1iZXJpbmcvY2hlY2tib3ggdXBkYXRlcy4gUmVzZXQgdG8gZmFsc2Ugb24gbW91c2Uva2V5Ym9hcmQgaW5wdXRcblxuICAgICAgICBjb25zdCBwb3NUb1JldHVybiA9IGVkaXRvci5nZXRDdXJzb3IoKTtcblxuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHN0YXJ0O1xuICAgICAgICBsZXQgZW5kSW5kZXggPSBlbmQ7XG4gICAgICAgIGxldCBuZXdMaW5lOiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRDdXJySW5kZXgoZWRpdG9yKTtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXggPSByZXN1bHQuaW5kZXg7XG4gICAgICAgICAgICBuZXdMaW5lID0gcmVzdWx0Lm1vdXNlQXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3TGluZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwb3NUb1JldHVybi5saW5lID0gbmV3TGluZTsgLy8gaWYgdGhlIGN1cnNvciBpcyBvdXRzaWRlIHRoZSBzY3JlZW4sIHBsYWNlIGl0IGluIHRoZSBzYW1lIGxpbmUgdGhlIG1vdXNlIGp1c3QgY2xpY2tlZCBhdFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIGNoZWNrYm94IHVwZGF0ZXNcbiAgICAgICAgbGV0IHJlb3JkZXJSZXN1bHQ6IFJlb3JkZXJSZXN1bHQgfCB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzTWFuYWdlci5nZXRMaXZlQ2hlY2tib3hVcGRhdGUoKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmVvcmRlclJlc3VsdCA9IHJlb3JkZXJDaGVja2xpc3QoZWRpdG9yLCBzdGFydEluZGV4LCBlbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIG51bWJlcmluZyB1cGRhdGVzXG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzTWFuYWdlci5nZXRMaXZlTnVtYmVyaW5nVXBkYXRlKCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIGlmIHJlb3JkZXJlZCBjaGVja2JveCwgcmVudW1iZXIgYmV0d2VlbiB0aGUgb3JpZ2luYWwgbG9jYXRpb24gYW5kIHRoZSBuZXcgb25lXG4gICAgICAgICAgICBpZiAocmVvcmRlclJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IHJlb3JkZXJSZXN1bHQuc3RhcnQ7XG4gICAgICAgICAgICAgICAgZW5kSW5kZXggPSByZW9yZGVyUmVzdWx0LmxpbWl0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlbnVtYmVyZXIucmVudW1iZXIoZWRpdG9yLCBzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZUN1cnNvclBvc2l0aW9uKGVkaXRvciwgcG9zVG9SZXR1cm4sIHJlb3JkZXJSZXN1bHQpO1xuICAgIH1cblxuICAgIGFzeW5jIG9ubG9hZCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkU2V0dGluZ3MoKTtcbiAgICAgICAgcmVnaXN0ZXJDb21tYW5kcyh0aGlzKTtcbiAgICAgICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBQbHVnaW5TZXR0aW5ncyh0aGlzLmFwcCwgdGhpcykpO1xuICAgICAgICB0aGlzLnNldHRpbmdzTWFuYWdlciA9IFNldHRpbmdzTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuICAgICAgICB0aGlzLnJlbnVtYmVyZXIgPSBuZXcgUmVudW1iZXJlcigpO1xuXG4gICAgICAgIC8vIGVkaXRvci1jaGFuZ2UgbGlzdGVuZXJcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50KFxuICAgICAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLm9uKFwiZWRpdG9yLWNoYW5nZVwiLCAoZWRpdG9yOiBFZGl0b3IpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBseVJlb3JkZXJpbmcoZWRpdG9yKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gZWRpdG9yLXBhc3RlIGxpc3RlbmVyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudChcbiAgICAgICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5vbihcImVkaXRvci1wYXN0ZVwiLCAoZXZ0OiBDbGlwYm9hcmRFdmVudCwgZWRpdG9yOiBFZGl0b3IpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IGhhbmRsZVBhc3RlLmNhbGwodGhpcywgZXZ0LCBlZGl0b3IpO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGBzdGFydDogJHtzdGFydH0sIGVuZDogJHtlbmR9YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja0NoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5UmVvcmRlcmluZyhlZGl0b3IsIHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBlZGl0b3ItZHJvcCBsaXN0ZW5lclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRXZlbnQoXG4gICAgICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2Uub24oXCJlZGl0b3ItZHJvcFwiLCAoZXZ0OiBEcmFnRXZlbnQsIGVkaXRvcjogRWRpdG9yKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBoYW5kbGVEcm9wLmNhbGwodGhpcywgZXZ0LCBlZGl0b3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseVJlb3JkZXJpbmcoZWRpdG9yLCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8ga2V5Ym9hcmQgc3Ryb2tlIGxpc3RlbmVyXG4gICAgICAgIHRoaXMuaGFuZGxlS2V5c3Ryb2tlQm91bmQgPSB0aGlzLmhhbmRsZUtleXN0cm9rZS5iaW5kKHRoaXMpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5oYW5kbGVLZXlzdHJva2VCb3VuZCk7IC8vIEtleXN0cm9rZSBsaXN0ZW5lclxuXG4gICAgICAgIC8vIG1vdXNlIGxpc3RlbmVyXG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VCb3VuZCA9IHRoaXMuaGFuZGxlTW91c2VDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuaGFuZGxlTW91c2VCb3VuZCk7IC8vIG1vdXNlIGxpc3RlbmVyXG4gICAgfVxuXG4gICAgaGFuZGxlS2V5c3Ryb2tlKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIC8vIGlmIHNwZWNpYWwga2V5LCBkb250IHJlbnVtYmVyIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgdGhpcy5ibG9ja0NoYW5nZXMgPSBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuYWx0S2V5O1xuICAgIH1cblxuICAgIC8vICBtb3VzZSBsaXN0ZW5lclxuICAgIGFzeW5jIGhhbmRsZU1vdXNlQ2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZXR0aW5nc01hbmFnZXIuZ2V0TGl2ZUNoZWNrYm94VXBkYXRlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNoZWNrYm94Q2xpY2tlZEF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHRhcmdldC5tYXRjaGVzKCdbdHlwZT1cImNoZWNrYm94XCJdJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY3RpdmVWaWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlVmlldz8uZWRpdG9yLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciwgbm90IHR5cGVkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvclZpZXcgPSBhY3RpdmVWaWV3LmVkaXRvci5jbSBhcyBFZGl0b3JWaWV3O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBhY3RpdmVWaWV3LmVkaXRvcjsgLy8gb2JzaWRpYW4ncyBlZGl0b3JcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zID0gZWRpdG9yVmlldy5wb3NBdENvb3Jkcyh7IHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFkgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja2JveENsaWNrZWRBdCA9IGVkaXRvci5vZmZzZXRUb1Bvcyhwb3MpLmxpbmU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gaGFuZGxlTW91c2VDbGljazpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5jaGVja2JveENsaWNrZWRBdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuYmxvY2tDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBvbnVubG9hZCgpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuaGFuZGxlS2V5c3Ryb2tlQm91bmQpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuaGFuZGxlTW91c2VCb3VuZCk7XG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZFNldHRpbmdzKCkge1xuICAgICAgICBjb25zdCBzZXR0aW5nc01hbmFnZXIgPSBTZXR0aW5nc01hbmFnZXIuZ2V0SW5zdGFuY2UoKTtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICAgICAgICBzZXR0aW5nc01hbmFnZXIuc2V0U2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3NNYW5hZ2VyID0gU2V0dGluZ3NNYW5hZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2F2ZURhdGEoc2V0dGluZ3NNYW5hZ2VyLmdldFNldHRpbmdzKCkpO1xuICAgIH1cblxuICAgIGdldFJlbnVtYmVyZXIoKTogUmVudW1iZXJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbnVtYmVyZXI7XG4gICAgfVxuXG4gICAgdXBkYXRlQ3Vyc29yUG9zaXRpb24oZWRpdG9yOiBFZGl0b3IsIG9yaWdpbmFsUG9zOiBFZGl0b3JQb3NpdGlvbiwgcmVvcmRlclJlc3VsdD86IFJlb3JkZXJSZXN1bHQpOiB2b2lkIHtcbiAgICAgICAgaWYgKGVkaXRvci5zb21ldGhpbmdTZWxlY3RlZCgpIHx8ICFyZW9yZGVyUmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgbGluZSB3aGVyZSB0aGUgY3Vyc29yIGlzIHdhcyBub3QgcmVvcmRlcmVkLCBsZWF2ZSBpdCBhcyBpdCB3YXNcbiAgICAgICAgLy8gZWxzZSwgcHV0IGl0IGF0IHRoZSBlbmQgb2YgdGhlIHNhbWUgbGluZVxuICAgICAgICAvLyBpZGVhbCBidXQgbm90IGltcGxlbWVudGVkOiBmb2xsb3cgdGhlIG9yaWdpbmFsIGxpbmUgdG8gaXRzIG5ldyBsb2NhdGlvblxuICAgICAgICBsZXQgbmV3UG9zaXRpb246IEVkaXRvclBvc2l0aW9uO1xuICAgICAgICBpZiAob3JpZ2luYWxQb3MubGluZSA8IHJlb3JkZXJSZXN1bHQuc3RhcnQgfHwgcmVvcmRlclJlc3VsdC5saW1pdCA8PSBvcmlnaW5hbFBvcy5saW5lKSB7XG4gICAgICAgICAgICBuZXdQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbFBvcy5saW5lLFxuICAgICAgICAgICAgICAgIGNoOiBvcmlnaW5hbFBvcy5jaCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUob3JpZ2luYWxQb3MubGluZSk7XG4gICAgICAgICAgICBuZXdQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbFBvcy5saW5lLFxuICAgICAgICAgICAgICAgIGNoOiBsaW5lLmxlbmd0aCwgLy8gbm90IGtlZXBpbmcgdGhlIG9yaWdpbmFsUG9zLmNoIGJhZCB1eCBvbiBuZXcgbGluZXMgYWZ0ZXIgY2hlY2tlZCBpdGVtc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3Iuc2V0Q3Vyc29yKG5ld1Bvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBnZXRDdXJySW5kZXgoZWRpdG9yOiBFZGl0b3IpOiB7IGluZGV4OiBudW1iZXI7IG1vdXNlQXQ/OiBudW1iZXIgfSB7XG4gICAgICAgIGNvbnN0IGlzSW5WaWV3ID0gdGhpcy5pc0N1cnNvckluVmlldygpO1xuXG4gICAgICAgIGlmICh0aGlzLmNoZWNrYm94Q2xpY2tlZEF0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jaGVja2JveENsaWNrZWRBdDtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tib3hDbGlja2VkQXQgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGlmICghaXNJblZpZXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpbmRleCwgbW91c2VBdDogaW5kZXggfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGluZGV4IH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBlZGl0b3IubGlzdFNlbGVjdGlvbnMoKVswXTtcbiAgICAgICAgcmV0dXJuIHsgaW5kZXg6IE1hdGgubWluKHNlbGVjdGlvbi5hbmNob3IubGluZSwgc2VsZWN0aW9uLmhlYWQubGluZSkgfTtcbiAgICB9XG5cbiAgICBpc0N1cnNvckluVmlldygpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgYWN0aXZlVmlldyA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XG4gICAgICAgIGlmIChhY3RpdmVWaWV3KSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yLCBub3QgdHlwZWRcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvclZpZXcgPSBhY3RpdmVWaWV3LmVkaXRvci5jbSBhcyBFZGl0b3JWaWV3O1xuICAgICAgICAgICAgY29uc3QgcG9zID0gZWRpdG9yVmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkO1xuICAgICAgICAgICAgY29uc3QgY29vcmRzID0gZWRpdG9yVmlldy5jb29yZHNBdFBvcyhwb3MpO1xuICAgICAgICAgICAgaWYgKGNvb3Jkcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvclJlY3QgPSBlZGl0b3JWaWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29vcmRzLnRvcCA+PSBlZGl0b3JSZWN0LnRvcCAmJiBjb29yZHMuYm90dG9tIDw9IGVkaXRvclJlY3QuYm90dG9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEVkaXRvciwgRWRpdG9yVHJhbnNhY3Rpb24sIE1hcmtkb3duVmlldyB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgZ2V0TGluZUluZm8sIGZpbmRGaXJzdE51bWJlcnNCeUluZGVudEZyb21FbmQsIGZpbmRGaXJzdE51bWJlcnNBZnRlckluZGV4IH0gZnJvbSBcInNyYy91dGlsc1wiO1xuaW1wb3J0IFNldHRpbmdzTWFuYWdlciBmcm9tIFwic3JjL1NldHRpbmdzTWFuYWdlclwiO1xuaW1wb3J0IHsgY2hlY2tQcmltZVN5bmMgfSBmcm9tIFwiY3J5cHRvXCI7XG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xuXG5mdW5jdGlvbiBoYW5kbGVQYXN0ZShldnQ6IENsaXBib2FyZEV2ZW50LCBlZGl0b3I6IEVkaXRvcik6IHsgc3RhcnQ/OiBudW1iZXI7IGVuZD86IG51bWJlciB9IHtcbiAgICBjb25zdCB1cGRhdGVOdW1iZXJpbmcgPSBTZXR0aW5nc01hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXRMaXZlTnVtYmVyaW5nVXBkYXRlKCk7XG4gICAgY29uc3QgdXBkYXRlQ2hlY2tsaXN0ID0gU2V0dGluZ3NNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0TGl2ZUNoZWNrYm94VXBkYXRlKCk7XG4gICAgaWYgKCF1cGRhdGVOdW1iZXJpbmcgJiYgIXVwZGF0ZUNoZWNrbGlzdCkge1xuICAgICAgICByZXR1cm4geyBzdGFydDogdW5kZWZpbmVkLCBlbmQ6IHVuZGVmaW5lZCB9O1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgY29udGVudCBmcm9tIGNsaXBib2FyZERhdGFcbiAgICBjb25zdCBjb250ZW50ID0gZXZ0LmNsaXBib2FyZERhdGE/LmdldERhdGEoXCJ0ZXh0XCIpO1xuICAgIGlmIChldnQuZGVmYXVsdFByZXZlbnRlZCB8fCAhY29udGVudCkge1xuICAgICAgICByZXR1cm4geyBzdGFydDogdW5kZWZpbmVkLCBlbmQ6IHVuZGVmaW5lZCB9O1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgZGVmYXVsdCBoYW5kbGluZ1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgLy8gR2V0IGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgY29uc3QgeyBhbmNob3IsIGhlYWQgfSA9IGVkaXRvci5saXN0U2VsZWN0aW9ucygpWzBdO1xuICAgIGNvbnN0IGJhc2VJbmRleCA9IE1hdGgubWluKGFuY2hvci5saW5lLCBoZWFkLmxpbmUpO1xuXG4gICAgLy8gTW9kaWZ5IHRleHQgaWYgc21hcnQgcGFzdGluZyBpcyBlbmFibGVkXG4gICAgbGV0IG1vZGlmaWVkQ29udGVudCA9IGNvbnRlbnQ7XG4gICAgY29uc3Qgc21hcnRQYXN0aW5nID0gU2V0dGluZ3NNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0U21hcnRQYXN0aW5nKCk7XG4gICAgaWYgKHNtYXJ0UGFzdGluZykge1xuICAgICAgICBjb25zdCBpbmRleEFmdGVyUGFzdGluZyA9IE1hdGgubWF4KGFuY2hvci5saW5lLCBoZWFkLmxpbmUpICsgMTtcbiAgICAgICAgbW9kaWZpZWRDb250ZW50ID0gbW9kaWZ5VGV4dChlZGl0b3IsIGNvbnRlbnQsIGluZGV4QWZ0ZXJQYXN0aW5nKSA/PyBjb250ZW50O1xuICAgIH1cblxuICAgIGVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKG1vZGlmaWVkQ29udGVudCk7IC8vIFBhc3RlIHRoZSBjb250ZW50XG5cbiAgICAvLyBDb3VudCBsaW5lcyBmb3IgcmV0dXJuIHZhbHVlIGNhbGN1bGF0aW9uXG4gICAgY29uc3QgY29udGVudExpbmVzID0gbW9kaWZpZWRDb250ZW50LnNwbGl0KFwiXFxuXCIpO1xuICAgIGNvbnN0IG51bU9mTGluZXMgPSBjb250ZW50TGluZXMubGVuZ3RoIC0gMTtcblxuICAgIC8vIENhbGN1bGF0ZSBlbmQgcG9zaXRpb25cbiAgICBjb25zdCBzdGFydCA9IGJhc2VJbmRleDtcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIG51bU9mTGluZXM7XG5cbiAgICByZXR1cm4geyBzdGFydCwgZW5kIH07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZURyb3AoZXZ0OiBEcmFnRXZlbnQsIGVkaXRvcjogRWRpdG9yKTogeyBzdGFydD86IG51bWJlcjsgZW5kPzogbnVtYmVyIH0ge1xuICAgIGNvbnN0IHNldHRpbmdzTWFuYWdlciA9IFNldHRpbmdzTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuICAgIGlmICghc2V0dGluZ3NNYW5hZ2VyLmdldExpdmVOdW1iZXJpbmdVcGRhdGUoKSAmJiAhc2V0dGluZ3NNYW5hZ2VyLmdldExpdmVDaGVja2JveFVwZGF0ZSgpKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiB1bmRlZmluZWQsIGVuZDogdW5kZWZpbmVkIH07XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBjbSBhY3RpdmUgdmlld1xuICAgIGNvbnN0IGFjdGl2ZVZpZXcgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpO1xuICAgIGlmICghYWN0aXZlVmlldyB8fCAhYWN0aXZlVmlldy5lZGl0b3IuaGFzRm9jdXMoKSkge1xuICAgICAgICByZXR1cm4geyBzdGFydDogdW5kZWZpbmVkLCBlbmQ6IHVuZGVmaW5lZCB9O1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yLCBub3QgdHlwZWRcbiAgICBjb25zdCBlZGl0b3JWaWV3ID0gYWN0aXZlVmlldy5lZGl0b3IuY20gYXMgRWRpdG9yVmlldztcblxuICAgIGNvbnN0IGRyb3BQb3NpdGlvbiA9IGVkaXRvclZpZXcucG9zQXRDb29yZHMoeyB4OiBldnQuY2xpZW50WCwgeTogZXZ0LmNsaWVudFkgfSk7XG4gICAgaWYgKGRyb3BQb3NpdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4geyBzdGFydDogdW5kZWZpbmVkLCBlbmQ6IHVuZGVmaW5lZCB9O1xuICAgIH1cblxuICAgIC8vIEdldCB0aGUgY29udGVudCBmcm9tIGRhdGFUcmFuc2ZlclxuICAgIGNvbnN0IGNvbnRlbnQgPSBldnQuZGF0YVRyYW5zZmVyPy5nZXREYXRhKFwidGV4dFwiKTtcbiAgICBpZiAoZXZ0LmRlZmF1bHRQcmV2ZW50ZWQgfHwgIWNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHVuZGVmaW5lZCwgZW5kOiB1bmRlZmluZWQgfTtcbiAgICB9XG5cbiAgICBldnQucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBkZWZhdWx0IGhhbmRsaW5nXG5cbiAgICBjb25zdCBwb3MgPSBlZGl0b3Iub2Zmc2V0VG9Qb3MoZHJvcFBvc2l0aW9uKTsgLy8gR2V0IHRoZSBkcm9wIHBvc2l0aW9uXG5cbiAgICAvLyBHZXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uICh3aGF0J3MgYmVpbmcgZHJhZ2dlZClcbiAgICBjb25zdCB7IGFuY2hvciwgaGVhZCB9ID0gZWRpdG9yLmxpc3RTZWxlY3Rpb25zKClbMF07XG5cbiAgICBsZXQgbW9kaWZpZWRDb250ZW50ID0gY29udGVudDtcbiAgICBjb25zdCBzbWFydFBhc3RpbmcgPSBTZXR0aW5nc01hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXRTbWFydFBhc3RpbmcoKTtcbiAgICBpZiAoc21hcnRQYXN0aW5nKSB7XG4gICAgICAgIG1vZGlmaWVkQ29udGVudCA9IG1vZGlmeVRleHQoZWRpdG9yLCBjb250ZW50LCBwb3MubGluZSkgPz8gY29udGVudDtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3Rpb25Gcm9tID0gYW5jaG9yLmxpbmUgPCBoZWFkLmxpbmUgfHwgKGFuY2hvci5saW5lID09PSBoZWFkLmxpbmUgJiYgYW5jaG9yLmNoIDwgaGVhZC5jaCkgPyBhbmNob3IgOiBoZWFkO1xuXG4gICAgY29uc3Qgc2VsZWN0aW9uVG8gPSBhbmNob3IubGluZSA+IGhlYWQubGluZSB8fCAoYW5jaG9yLmxpbmUgPT09IGhlYWQubGluZSAmJiBhbmNob3IuY2ggPiBoZWFkLmNoKSA/IGFuY2hvciA6IGhlYWQ7XG5cbiAgICAvLyBDcmVhdGUgYW5kIGV4ZWN1dGUgdGhlIHRyYW5zYWN0aW9uXG4gICAgY29uc3QgdHJhbnNhY3Rpb246IEVkaXRvclRyYW5zYWN0aW9uID0ge1xuICAgICAgICBjaGFuZ2VzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZnJvbTogc2VsZWN0aW9uRnJvbSxcbiAgICAgICAgICAgICAgICB0bzogc2VsZWN0aW9uVG8sXG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZnJvbTogcG9zLFxuICAgICAgICAgICAgICAgIHRvOiBwb3MsXG4gICAgICAgICAgICAgICAgdGV4dDogbW9kaWZpZWRDb250ZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICB9O1xuXG4gICAgZWRpdG9yLnRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcblxuICAgIC8vIENhbGN1bGF0ZSBlbmQgcG9zaXRpb24gb2YgaW5zZXJ0ZWQgdGV4dFxuICAgIGNvbnN0IGxpbmVzID0gbW9kaWZpZWRDb250ZW50LnNwbGl0KFwiXFxuXCIpO1xuICAgIGNvbnN0IGVuZFBvcyA9IHtcbiAgICAgICAgbGluZTogcG9zLmxpbmUgKyBsaW5lcy5sZW5ndGggLSAxLFxuICAgICAgICBjaDogbGluZXMubGVuZ3RoID4gMSA/IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCA6IHBvcy5jaCArIG1vZGlmaWVkQ29udGVudC5sZW5ndGgsXG4gICAgfTtcblxuICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5taW4ocG9zLmxpbmUsIHNlbGVjdGlvbkZyb20ubGluZSk7XG4gICAgY29uc3QgZW5kID0gTWF0aC5tYXgoZW5kUG9zLmxpbmUsIHNlbGVjdGlvblRvLmxpbmUpICsgMTtcblxuICAgIHJldHVybiB7IHN0YXJ0LCBlbmQgfTtcbn1cblxuZnVuY3Rpb24gbW9kaWZ5VGV4dChlZGl0b3I6IEVkaXRvciwgcGFzdGVkVGV4dDogc3RyaW5nLCBwYXN0ZVBvc2l0aW9uOiBudW1iZXIpIHtcbiAgICBjb25zdCBjdXJyZW50TGluZUluZm8gPSBnZXRMaW5lSW5mbyhlZGl0b3IuZ2V0TGluZShwYXN0ZVBvc2l0aW9uKSk7XG4gICAgaWYgKCFjdXJyZW50TGluZUluZm8ubnVtYmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwYXN0ZWRMaW5lcyA9IHBhc3RlZFRleHQuc3BsaXQoXCJcXG5cIik7XG4gICAgY29uc3Qgc291cmNlTGlzdE51bWJlcnMgPSBmaW5kRmlyc3ROdW1iZXJzQnlJbmRlbnRGcm9tRW5kKHBhc3RlZExpbmVzKTtcbiAgICBjb25zdCB0YXJnZXRMaXN0TnVtYmVycyA9IGZpbmRGaXJzdE51bWJlcnNBZnRlckluZGV4KGVkaXRvciwgcGFzdGVQb3NpdGlvbik7XG5cbiAgICBmb3IgKGxldCBpbmRlbnRMZXZlbCA9IDA7IGluZGVudExldmVsIDwgc291cmNlTGlzdE51bWJlcnMubGVuZ3RoOyBpbmRlbnRMZXZlbCsrKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZUxpbmVJbmRleCA9IHNvdXJjZUxpc3ROdW1iZXJzW2luZGVudExldmVsXTtcbiAgICAgICAgY29uc3QgbmV3TnVtYmVyID0gdGFyZ2V0TGlzdE51bWJlcnNbaW5kZW50TGV2ZWxdO1xuXG4gICAgICAgIGlmIChzb3VyY2VMaW5lSW5kZXggPT09IHVuZGVmaW5lZCB8fCBuZXdOdW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzb3VyY2VMaW5lID0gcGFzdGVkTGluZXNbc291cmNlTGluZUluZGV4XTtcbiAgICAgICAgY29uc3Qgc291cmNlTGluZUluZm8gPSBnZXRMaW5lSW5mbyhzb3VyY2VMaW5lKTtcblxuICAgICAgICBwYXN0ZWRMaW5lc1tzb3VyY2VMaW5lSW5kZXhdID1cbiAgICAgICAgICAgIHNvdXJjZUxpbmUuc2xpY2UoMCwgc291cmNlTGluZUluZm8uc3BhY2VDaGFyc051bSkgK1xuICAgICAgICAgICAgbmV3TnVtYmVyICtcbiAgICAgICAgICAgIFwiLiBcIiArXG4gICAgICAgICAgICBzb3VyY2VMaW5lLnNsaWNlKHNvdXJjZUxpbmVJbmZvLnRleHRPZmZzZXQpO1xuICAgIH1cblxuICAgIGNvbnN0IHJlbnVtYmVyZWRUZXh0ID0gcGFzdGVkTGluZXMuam9pbihcIlxcblwiKTtcblxuICAgIHJldHVybiByZW51bWJlcmVkVGV4dDtcbn1cblxuZXhwb3J0IHsgbW9kaWZ5VGV4dCwgaGFuZGxlUGFzdGUsIGhhbmRsZURyb3AgfTtcbiIsICJpbXBvcnQgeyBQbHVnaW5TZXR0aW5ncywgUmVudW1iZXJpbmdTZXR0aW5ncywgQ2hlY2tsaXN0U2V0dGluZ3MgfSBmcm9tIFwiLi90eXBlc1wiO1xuXG5jb25zdCBERUZBVUxUX1JFTlVNQkVSSU5HX1NFVFRJTkdTOiBSZW51bWJlcmluZ1NldHRpbmdzID0ge1xuICAgIGxpdmVVcGRhdGU6IHRydWUsXG4gICAgc21hcnRQYXN0aW5nOiB0cnVlLFxuICAgIHN0YXJ0c0Zyb21PbmU6IHRydWUsXG59O1xuXG5jb25zdCBERUZBVUxUX0NIRUNLTElTVF9TRVRUSU5HUzogQ2hlY2tsaXN0U2V0dGluZ3MgPSB7XG4gICAgbGl2ZVVwZGF0ZTogdHJ1ZSxcbiAgICBjaGVja2VkSXRlbXNBdEJvdHRvbTogdHJ1ZSxcbiAgICBzb3J0U3BlY2lhbENoYXJzOiB0cnVlLFxuICAgIGNoYXJzVG9EZWxldGU6IFwiXCIsXG59O1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9TRVRUSU5HUzogUGx1Z2luU2V0dGluZ3MgPSB7XG4gICAgcmVudW1iZXJpbmc6IERFRkFVTFRfUkVOVU1CRVJJTkdfU0VUVElOR1MsXG4gICAgY2hlY2tsaXN0OiBERUZBVUxUX0NIRUNLTElTVF9TRVRUSU5HUyxcbiAgICBpbmRlbnRTaXplOiA0LFxufTtcblxuLy8gYSBzaW5nbGV0b24gZm9yIHRoZSBzZXR0aW5nc1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2V0dGluZ3NNYW5hZ2VyIHtcbiAgICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogU2V0dGluZ3NNYW5hZ2VyO1xuICAgIHByaXZhdGUgc2V0dGluZ3M6IFBsdWdpblNldHRpbmdzO1xuXG4gICAgcHJpdmF0ZSBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncyA9IERFRkFVTFRfU0VUVElOR1M7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBnZXRJbnN0YW5jZSgpOiBTZXR0aW5nc01hbmFnZXIge1xuICAgICAgICBpZiAoIVNldHRpbmdzTWFuYWdlci5pbnN0YW5jZSkge1xuICAgICAgICAgICAgU2V0dGluZ3NNYW5hZ2VyLmluc3RhbmNlID0gbmV3IFNldHRpbmdzTWFuYWdlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFNldHRpbmdzTWFuYWdlci5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0U2V0dGluZ3MoKTogUGx1Z2luU2V0dGluZ3Mge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncztcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0U2V0dGluZ3Moc2V0dGluZ3M6IFBsdWdpblNldHRpbmdzKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0TGl2ZU51bWJlcmluZ1VwZGF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MucmVudW1iZXJpbmcubGl2ZVVwZGF0ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0TGl2ZU51bWJlcmluZ1VwZGF0ZSh2YWx1ZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLnNldHRpbmdzLnJlbnVtYmVyaW5nLmxpdmVVcGRhdGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0U21hcnRQYXN0aW5nKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5yZW51bWJlcmluZy5zbWFydFBhc3Rpbmc7XG4gICAgfVxuXG4gICAgcHVibGljIHNldFNtYXJ0UGFzdGluZyh2YWx1ZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLnNldHRpbmdzLnJlbnVtYmVyaW5nLnNtYXJ0UGFzdGluZyA9IHZhbHVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRTdGFydHNGcm9tT25lKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5yZW51bWJlcmluZy5zdGFydHNGcm9tT25lO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXRTdGFydHNGcm9tT25lKHZhbHVlOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MucmVudW1iZXJpbmcuc3RhcnRzRnJvbU9uZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRJbmRlbnRTaXplKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLmluZGVudFNpemU7XG4gICAgfVxuXG4gICAgcHVibGljIHNldEluZGVudFNpemUodmFsdWU6IG51bWJlcik6IHZvaWQge1xuICAgICAgICB0aGlzLnNldHRpbmdzLmluZGVudFNpemUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0TGl2ZUNoZWNrYm94VXBkYXRlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5jaGVja2xpc3QubGl2ZVVwZGF0ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0TGl2ZUNoZWNrYm94VXBkYXRlKHZhbHVlOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MuY2hlY2tsaXN0LmxpdmVVcGRhdGUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaXNDaGVja2VkSXRlbXNBdEJvdHRvbSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MuY2hlY2tsaXN0LmNoZWNrZWRJdGVtc0F0Qm90dG9tO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXRDaGVja2VkSXRlbXNBdEJvdHRvbSh2YWx1ZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLnNldHRpbmdzLmNoZWNrbGlzdC5jaGVja2VkSXRlbXNBdEJvdHRvbSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRDaGFyc1RvRGVsZXRlKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzLmNoZWNrbGlzdC5jaGFyc1RvRGVsZXRlO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXRDaGFyc1RvRGVsZXRlKHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zZXR0aW5ncy5jaGVja2xpc3QuY2hhcnNUb0RlbGV0ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXRTb3J0U3BlY2lhbENoYXJzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy5jaGVja2xpc3Quc29ydFNwZWNpYWxDaGFycztcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0U29ydFNwZWNpYWxDaGFycyh2YWx1ZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLnNldHRpbmdzLmNoZWNrbGlzdC5zb3J0U3BlY2lhbENoYXJzID0gdmFsdWU7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEVkaXRvciB9IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgU2V0dGluZ3NNYW5hZ2VyIGZyb20gXCIuL1NldHRpbmdzTWFuYWdlclwiO1xyXG5pbXBvcnQgeyBMaW5lSW5mbyB9IGZyb20gXCIuL3R5cGVzXCI7XHJcbmltcG9ydCB7IHJlc291cmNlTGltaXRzIH0gZnJvbSBcIndvcmtlcl90aHJlYWRzXCI7XHJcblxyXG4vLyBleHRyYWN0IGluZm9ybWF0aW9uIGZyb20gYSBsaW5lIG9mIHRleHRcclxuZnVuY3Rpb24gZ2V0TGluZUluZm8obGluZTogc3RyaW5nKTogTGluZUluZm8ge1xyXG4gICAgY29uc3QgbGVuZ3RoID0gbGluZS5sZW5ndGg7XHJcbiAgICBsZXQgb2Zmc2V0ID0gMDtcclxuICAgIGxldCBudW1PZlNwYWNlSW5kZW50cyA9IDA7XHJcblxyXG4gICAgY29uc3QgaW5kZW50U2l6ZSA9IFNldHRpbmdzTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldEluZGVudFNpemUoKTtcclxuXHJcbiAgICAvLyBudW0gb2Ygc3BhY2VzXHJcbiAgICB3aGlsZSAob2Zmc2V0IDwgbGVuZ3RoICYmIChsaW5lW29mZnNldF0gPT09IFwiIFwiIHx8IGxpbmVbb2Zmc2V0XSA9PT0gXCJcXHRcIikpIHtcclxuICAgICAgICBudW1PZlNwYWNlSW5kZW50cyArPSBsaW5lW29mZnNldF0gPT09IFwiIFwiID8gMSA6IGluZGVudFNpemU7XHJcbiAgICAgICAgb2Zmc2V0Kys7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgc3BhY2VDaGFyc051bSA9IG9mZnNldDtcclxuXHJcbiAgICAvLyBudW1iZXIgaW5kaWNlc1xyXG4gICAgd2hpbGUgKFxyXG4gICAgICAgIG9mZnNldCA8IGxlbmd0aCAmJlxyXG4gICAgICAgIFwiMFwiLmNoYXJDb2RlQXQoMCkgPD0gbGluZS5jaGFyQ29kZUF0KG9mZnNldCkgJiZcclxuICAgICAgICBsaW5lLmNoYXJDb2RlQXQob2Zmc2V0KSA8PSBcIjlcIi5jaGFyQ29kZUF0KDApXHJcbiAgICApIHtcclxuICAgICAgICBvZmZzZXQrKztcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpc051bWJlckRldGVjdGVkID0gc3BhY2VDaGFyc051bSAhPT0gb2Zmc2V0ICYmIGxpbmVbb2Zmc2V0XSA9PT0gXCIuXCIgJiYgbGluZVtvZmZzZXQgKyAxXSA9PT0gXCIgXCI7XHJcblxyXG4gICAgbGV0IG51bWJlciA9IHVuZGVmaW5lZDtcclxuXHJcbiAgICBpZiAoIWlzTnVtYmVyRGV0ZWN0ZWQpIHtcclxuICAgICAgICBvZmZzZXQgPSBzcGFjZUNoYXJzTnVtO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBwYXJzZWROdW0gPSBwYXJzZUludChsaW5lLnNsaWNlKHNwYWNlQ2hhcnNOdW0sIG9mZnNldCkpO1xyXG5cclxuICAgICAgICBpZiAoaXNOYU4ocGFyc2VkTnVtKSkge1xyXG4gICAgICAgICAgICBvZmZzZXQgPSBzcGFjZUNoYXJzTnVtO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG51bWJlciA9IHBhcnNlZE51bTtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IDI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNoZWNrYm94Q2hhciA9IGdldENoZWNrYm94SW5mbyhsaW5lLCBvZmZzZXQsIGlzTnVtYmVyRGV0ZWN0ZWQpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc3BhY2VDaGFyc051bSxcclxuICAgICAgICBzcGFjZUluZGVudDogbnVtT2ZTcGFjZUluZGVudHMsXHJcbiAgICAgICAgbnVtYmVyLFxyXG4gICAgICAgIHRleHRPZmZzZXQ6IG9mZnNldCxcclxuICAgICAgICBjaGVja2JveENoYXIsXHJcbiAgICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRDaGVja2JveEluZm8obGluZTogc3RyaW5nLCBpbmRleDogbnVtYmVyLCBpc051bWJlckRldGVjdGVkOiBib29sZWFuKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuICAgIGNvbnN0IE5VTUJFUkVEX0NIRUNLQk9YID0gL15cXHMqXFxbKC4pXFxdIC87IC8vIGNoZWNrYm94IGluc2lkZSBhIG51bWJlcmVkIGl0ZW1cclxuICAgIGNvbnN0IFVOTlVNQkVSRURfQ0hFQ0tCT1ggPSAvXlxccyotIFxcWyguKVxcXSAvOyAvLyB1bm51bWJlcmVkIGNoZWNrYm94LCBpbmRlbnRlZCBvciBub3RcclxuXHJcbiAgICBjb25zdCBwYXR0ZXJuID0gaXNOdW1iZXJEZXRlY3RlZCA/IE5VTUJFUkVEX0NIRUNLQk9YIDogVU5OVU1CRVJFRF9DSEVDS0JPWDtcclxuICAgIGNvbnN0IHN0cmluZ1RvQ2hlY2sgPSBpc051bWJlckRldGVjdGVkID8gbGluZS5zbGljZShpbmRleCkgOiBsaW5lO1xyXG5cclxuICAgIGNvbnN0IG1hdGNoID0gc3RyaW5nVG9DaGVjay5tYXRjaChwYXR0ZXJuKTtcclxuICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgIHJldHVybiBtYXRjaFsxXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vLyBUT0RPIG5vdCBwZXJmZWN0LCBkb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCBpbmRlbnRzIGFuZCBpbSBub3Qgc3VyZSBpZiBpdHMgaW50ZW5kZW5kIChpdCBtaWdodCBiZSlcclxuLy8gZ2V0cyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0gaW4gYSBudW1iZXJlZCBsaXN0XHJcbmZ1bmN0aW9uIGdldExpc3RTdGFydChlZGl0b3I6IEVkaXRvciwgY3VyckxpbmVJbmRleDogbnVtYmVyKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcclxuICAgIGlmIChjdXJyTGluZUluZGV4IDwgMCB8fCBlZGl0b3IubGFzdExpbmUoKSA8IGN1cnJMaW5lSW5kZXgpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGN1cnJJbmZvID0gZ2V0TGluZUluZm8oZWRpdG9yLmdldExpbmUoY3VyckxpbmVJbmRleCkpO1xyXG4gICAgaWYgKGN1cnJJbmZvLm51bWJlciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGN1cnJMaW5lSW5kZXg7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHByZXZJbmRleCA9IGN1cnJMaW5lSW5kZXggLSAxO1xyXG4gICAgd2hpbGUgKDAgPD0gcHJldkluZGV4ICYmIGdldExpbmVJbmZvKGVkaXRvci5nZXRMaW5lKHByZXZJbmRleCkpLm51bWJlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcHJldkluZGV4LS07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHByZXZJbmRleCArIDE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldFByZXZJdGVtSW5kZXgoZWRpdG9yOiBFZGl0b3IsIGluZGV4OiBudW1iZXIpOiBudW1iZXIgfCB1bmRlZmluZWQge1xyXG4gICAgaWYgKGluZGV4IDw9IDAgfHwgZWRpdG9yLmxhc3RMaW5lKCkgPCBpbmRleCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgY3VyclNwYWNlT2Zmc2V0ID0gZ2V0TGluZUluZm8oZWRpdG9yLmdldExpbmUoaW5kZXgpKS5zcGFjZUluZGVudDtcclxuXHJcbiAgICBmb3IgKGxldCBwcmV2SW5kZXggPSBpbmRleCAtIDE7IHByZXZJbmRleCA+PSAwOyBwcmV2SW5kZXgtLSkge1xyXG4gICAgICAgIGNvbnN0IGluZm8gPSBnZXRMaW5lSW5mbyhlZGl0b3IuZ2V0TGluZShwcmV2SW5kZXgpKTtcclxuXHJcbiAgICAgICAgLy8gU2tpcCBsaW5lcyB3aXRoIGRlZXBlciBpbmRlbnRhdGlvblxyXG4gICAgICAgIGlmIChpbmZvLnNwYWNlSW5kZW50ID4gY3VyclNwYWNlT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSWYgd2UgZmluZCBhIGxpbmUgd2l0aCBzYW1lIGluZGVudGF0aW9uIGFuZCBpdCBoYXMgYSBudW1iZXIsIHdlIGZvdW5kIG91ciBtYXRjaFxyXG4gICAgICAgIGlmIChpbmZvLnNwYWNlSW5kZW50ID09PSBjdXJyU3BhY2VPZmZzZXQgJiYgaW5mby5udW1iZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcHJldkluZGV4O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG59XHJcblxyXG5mdW5jdGlvbiBmaW5kRmlyc3ROdW1iZXJzQWZ0ZXJJbmRleChlZGl0b3I6IEVkaXRvciwgc3RhcnRJbmRleDogbnVtYmVyKTogbnVtYmVyW10ge1xyXG4gICAgLy8gQXJyYXkgdG8gc3RvcmUgdGhlIGZpcnN0IG51bWJlciBmb3VuZCBmb3IgZWFjaCBpbmRlbnQgbGV2ZWwgKGdvaW5nIGZvcndhcmQpXHJcbiAgICBjb25zdCByZXN1bHQ6IG51bWJlcltdID0gW107XHJcblxyXG4gICAgLy8gR2V0IHRoZSBpbmRlbnQgbGV2ZWwgb2YgdGhlIGN1cnJlbnQgbGluZSB0byBzZXQgb3VyIG1heGltdW0gdHJhY2tpbmcgdGhyZXNob2xkXHJcbiAgICBjb25zdCBjdXJyZW50TGluZUluZm8gPSBnZXRMaW5lSW5mbyhlZGl0b3IuZ2V0TGluZShzdGFydEluZGV4KSk7XHJcblxyXG4gICAgaWYgKCFjdXJyZW50TGluZUluZm8gfHwgY3VycmVudExpbmVJbmZvLnNwYWNlSW5kZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gW107IC8vIEludmFsaWQgc3RhcnQgbGluZVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEluaXRpYWwgbWF4aW11bSBpbmRlbnQgbGV2ZWwgd2UgY2FyZSBhYm91dFxyXG4gICAgbGV0IG1heEluZGVudFRvVHJhY2sgPSBJbmZpbml0eTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8PSBlZGl0b3IubGFzdExpbmUoKTsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpO1xyXG4gICAgICAgIGNvbnN0IGluZm8gPSBnZXRMaW5lSW5mbyhsaW5lKTtcclxuXHJcbiAgICAgICAgLy8gU2tpcCBpZiB3ZSBjYW4ndCBnZXQgaW5mb1xyXG4gICAgICAgIGlmIChpbmZvLnNwYWNlSW5kZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50SW5kZW50ID0gaW5mby5zcGFjZUluZGVudDtcclxuXHJcbiAgICAgICAgLy8gU2tpcCBpZiB0aGlzIGluZGVudCBpcyBoaWdoZXIgdGhhbiB3aGF0IHdlIGNhcmUgYWJvdXRcclxuICAgICAgICBpZiAoY3VycmVudEluZGVudCA+IG1heEluZGVudFRvVHJhY2spIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB0aGUgbGluZSBoYXMgbm8gbnVtYmVyLCBjb250aW51ZSB0byBuZXh0IGxpbmVcclxuICAgICAgICBpZiAoaW5mby5udW1iZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFN0b3JlIHRoZSBudW1iZXIgZm9yIHRoaXMgaW5kZW50IGxldmVsIGlmIG5vdCBhbHJlYWR5IHNldFxyXG4gICAgICAgIGlmIChyZXN1bHRbY3VycmVudEluZGVudF0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXN1bHRbY3VycmVudEluZGVudF0gPSBpbmZvLm51bWJlcjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE9ubHkgdXBkYXRlIG1heEluZGVudFRvVHJhY2sgQUZURVIgd2UndmUgc3RvcmVkIHRoZSBudW1iZXJcclxuICAgICAgICBpZiAoY3VycmVudEluZGVudCA8IG1heEluZGVudFRvVHJhY2spIHtcclxuICAgICAgICAgICAgbWF4SW5kZW50VG9UcmFjayA9IGN1cnJlbnRJbmRlbnQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJZiB3ZSd2ZSBmb3VuZCBpbmRlbnQgMCwgd2UncmUgZG9uZSAocmVhY2hlZCB0aGUgbG93ZXN0IGxldmVsKVxyXG4gICAgICAgIGlmIChjdXJyZW50SW5kZW50ID09PSAwICYmIHJlc3VsdFswXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vLyBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGFzdCBudW1iZXJlZCBsaXN0XHJcbmZ1bmN0aW9uIGZpbmRGaXJzdE51bWJlcnNCeUluZGVudEZyb21FbmQobGluZXM6IHN0cmluZ1tdKTogbnVtYmVyW10ge1xyXG4gICAgLy8gQXJyYXkgdG8gc3RvcmUgdGhlIGZpcnN0IG51bWJlciBmb3VuZCBmb3IgZWFjaCBpbmRlbnQgbGV2ZWwgKGZyb20gdGhlIGVuZClcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgLy8gVHJhY2sgdGhlIG1heGltdW0gaW5kZW50IGxldmVsIHdlIHN0aWxsIGNhcmUgYWJvdXQsIHdoaWNoIGlzIHRoZSBtaW5pbXVtIHdlIGhhdmUgc2VlblxyXG4gICAgbGV0IG1heEluZGVudFRvVHJhY2sgPSBJbmZpbml0eTtcclxuXHJcbiAgICAvLyBQcm9jZXNzIGxpbmVzIGluIHJldmVyc2Ugb3JkZXJcclxuICAgIGZvciAobGV0IGkgPSBsaW5lcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcclxuICAgICAgICBjb25zdCBpbmZvID0gZ2V0TGluZUluZm8obGluZSk7XHJcblxyXG4gICAgICAgIC8vIFNraXAgaWYgd2UgY2FuJ3QgZ2V0IGluZm9cclxuICAgICAgICBpZiAoIWluZm8gfHwgaW5mby5zcGFjZUluZGVudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY3VycmVudEluZGVudCA9IGluZm8uc3BhY2VJbmRlbnQ7XHJcblxyXG4gICAgICAgIC8vIFNraXAgaWYgdGhpcyBpbmRlbnQgaXMgaGlnaGVyIHRoYW4gd2hhdCB3ZSBjYXJlIGFib3V0XHJcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRlbnQgPiBtYXhJbmRlbnRUb1RyYWNrKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBtaW5pbXVtIGluZGVudCB3ZSBjYXJlIGFib3V0XHJcbiAgICAgICAgbWF4SW5kZW50VG9UcmFjayA9IGN1cnJlbnRJbmRlbnQ7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBsaW5lIGhhcyBubyBudW1iZXIsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VzcyBhbnkgbW9yZSBsaW5lc1xyXG4gICAgICAgIC8vIGF0IHRoaXMgaW5kZW50IGxldmVsIG9yIGhpZ2hlclxyXG4gICAgICAgIGlmIChpbmZvLm51bWJlciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBhdCBpbmRlbnQgMCB3aXRoIG5vIG51bWJlciwgd2UgY2FuIGJyZWFrIGVudGlyZWx5XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdG9yZSB0aGUgbnVtYmVyIGZvciB0aGlzIGluZGVudCBsZXZlbFxyXG4gICAgICAgIHJlc3VsdFtjdXJyZW50SW5kZW50XSA9IGk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IHsgZ2V0TGluZUluZm8sIGdldExpc3RTdGFydCwgZ2V0UHJldkl0ZW1JbmRleCwgZmluZEZpcnN0TnVtYmVyc0J5SW5kZW50RnJvbUVuZCwgZmluZEZpcnN0TnVtYmVyc0FmdGVySW5kZXggfTtcclxuIiwgImltcG9ydCBBdXRvUmVvcmRlcmluZyBmcm9tIFwiLi4vbWFpblwiO1xuaW1wb3J0IHsgRWRpdG9yLCBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IHJlb3JkZXJDaGVja2xpc3QsIGRlbGV0ZUNoZWNrZWQgfSBmcm9tIFwiLi9jaGVja2JveFwiO1xuaW1wb3J0IFNldHRpbmdzTWFuYWdlciBmcm9tIFwiLi9TZXR0aW5nc01hbmFnZXJcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyQ29tbWFuZHMocGx1Z2luOiBBdXRvUmVvcmRlcmluZykge1xuICAgIHBsdWdpbi5hZGRDb21tYW5kKHtcbiAgICAgICAgaWQ6IFwiMS1yZW5ldW1iZXItc2VsZWN0aW9uXCIsXG4gICAgICAgIG5hbWU6IFwiUmVudW1iZXIgbGlzdHM6IGluIHNlbGVjdGlvbiBvciBhdCBjdXJzb3JcIixcbiAgICAgICAgZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBhbmNob3IsIGhlYWQgfSA9IGVkaXRvci5saXN0U2VsZWN0aW9ucygpWzBdO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRMaW5lID0gTWF0aC5taW4oYW5jaG9yLmxpbmUsIGhlYWQubGluZSk7XG4gICAgICAgICAgICBjb25zdCBlbmRMaW5lID0gTWF0aC5tYXgoYW5jaG9yLmxpbmUsIGhlYWQubGluZSkgKyAxO1xuXG4gICAgICAgICAgICBwbHVnaW4uZ2V0UmVudW1iZXJlcigpLnJlbnVtYmVyKGVkaXRvciwgc3RhcnRMaW5lLCBlbmRMaW5lKTtcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHBsdWdpbi5hZGRDb21tYW5kKHtcbiAgICAgICAgaWQ6IFwiMi1yZW51bWJlci1lbnRpcmUtbm90ZVwiLFxuICAgICAgICBuYW1lOiBcIlJlbnVtYmVyIGxpc3RzOiBlbnRpcmUgbm90ZVwiLFxuICAgICAgICBlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yKSA9PiB7XG4gICAgICAgICAgICBwbHVnaW4uZ2V0UmVudW1iZXJlcigpLnJlbnVtYmVyKGVkaXRvciwgMCwgZWRpdG9yLmxhc3RMaW5lKCkgKyAxKTtcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHBsdWdpbi5hZGRDb21tYW5kKHtcbiAgICAgICAgaWQ6IFwiMy1jaGVja2xpc3QtYXQtY3Vyc29yXCIsXG4gICAgICAgIG5hbWU6IFwiUmVvcmRlciBjaGVja2JveGVzOiBpbiBzZWxlY3Rpb24gb3IgYXQgY3Vyc29yXCIsXG4gICAgICAgIGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBvc1RvUmV0dXJuID0gZWRpdG9yLmdldEN1cnNvcigpO1xuICAgICAgICAgICAgY29uc3QgcmVudW1iZXJlciA9IHBsdWdpbi5nZXRSZW51bWJlcmVyKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgYW5jaG9yLCBoZWFkIH0gPSBlZGl0b3IubGlzdFNlbGVjdGlvbnMoKVswXTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0TGluZSA9IE1hdGgubWluKGFuY2hvci5saW5lLCBoZWFkLmxpbmUpO1xuICAgICAgICAgICAgY29uc3QgZW5kTGluZSA9IE1hdGgubWF4KGFuY2hvci5saW5lLCBoZWFkLmxpbmUpICsgMTtcblxuICAgICAgICAgICAgY29uc3QgcmVvcmRlclJlc3VsdCA9IHJlb3JkZXJDaGVja2xpc3QoZWRpdG9yLCBzdGFydExpbmUsIGVuZExpbmUpO1xuXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3NNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0TGl2ZU51bWJlcmluZ1VwZGF0ZSgpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlb3JkZXJSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZW51bWJlcmVyLnJlbnVtYmVyKGVkaXRvciwgcmVvcmRlclJlc3VsdC5zdGFydCwgcmVvcmRlclJlc3VsdC5saW1pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwbHVnaW4udXBkYXRlQ3Vyc29yUG9zaXRpb24oZWRpdG9yLCBwb3NUb1JldHVybiwgcmVvcmRlclJlc3VsdCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBwbHVnaW4uYWRkQ29tbWFuZCh7XG4gICAgICAgIGlkOiBcIjQtY2hlY2tsaXN0LWVudGlyZS1ub3RlXCIsXG4gICAgICAgIG5hbWU6IFwiUmVvcmRlciBjaGVja2JveGVzOiBlbnRpcmUgbm90ZVwiLFxuICAgICAgICBlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaW5lVG9SZXR1cm4gPSBlZGl0b3IuZ2V0Q3Vyc29yKCkubGluZTtcbiAgICAgICAgICAgIGNvbnN0IHJlbnVtYmVyZXIgPSBwbHVnaW4uZ2V0UmVudW1iZXJlcigpO1xuXG4gICAgICAgICAgICBjb25zdCByZW9yZGVyUmVzdWx0ID0gcmVvcmRlckNoZWNrbGlzdChlZGl0b3IsIDAsIGVkaXRvci5sYXN0TGluZSgpICsgMSk7XG5cbiAgICAgICAgICAgIGlmIChTZXR0aW5nc01hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXRMaXZlTnVtYmVyaW5nVXBkYXRlKCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVvcmRlclJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbnVtYmVyZXIucmVudW1iZXIoZWRpdG9yLCByZW9yZGVyUmVzdWx0LnN0YXJ0LCByZW9yZGVyUmVzdWx0LmxpbWl0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVkaXRvci5zZXRDdXJzb3IoeyBsaW5lOiBsaW5lVG9SZXR1cm4sIGNoOiBlZGl0b3IuZ2V0TGluZShsaW5lVG9SZXR1cm4pLmxlbmd0aCB9KTtcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIHBsdWdpbi5hZGRDb21tYW5kKHtcbiAgICAgICAgaWQ6IFwiNS1jaGVja2xpc3QtZGVsZXRlLWNoZWNrZWQtaXRlbXNcIixcbiAgICAgICAgbmFtZTogXCJEZWxldGUgYWxsIGNoZWNrZWQgSXRlbXMgaW4gbm90ZVwiLFxuICAgICAgICBlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaW5lVG9SZXR1cm4gPSBlZGl0b3IuZ2V0Q3Vyc29yKCkubGluZTtcbiAgICAgICAgICAgIGNvbnN0IHJlbnVtYmVyZXIgPSBwbHVnaW4uZ2V0UmVudW1iZXJlcigpO1xuXG4gICAgICAgICAgICBjb25zdCB7IGRlbGV0ZVJlc3VsdCwgZGVsZXRlZEl0ZW1Db3VudCB9ID0gZGVsZXRlQ2hlY2tlZChlZGl0b3IpO1xuXG4gICAgICAgICAgICBpZiAoU2V0dGluZ3NNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0TGl2ZU51bWJlcmluZ1VwZGF0ZSgpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmVudW1iZXJlci5yZW51bWJlcihlZGl0b3IsIGRlbGV0ZVJlc3VsdC5zdGFydCwgZGVsZXRlUmVzdWx0LmxpbWl0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3Qgbm90aWNlU3RyaW5nID1cbiAgICAgICAgICAgICAgICBkZWxldGVkSXRlbUNvdW50ID4gMCA/IGBEZWxldGVkICR7ZGVsZXRlZEl0ZW1Db3VudH0gbGluZXNgIDogXCJObyBjaGVja2VkIGl0ZW1zIHRvIGRlbGV0ZVwiO1xuXG4gICAgICAgICAgICBuZXcgTm90aWNlKG5vdGljZVN0cmluZyk7XG5cbiAgICAgICAgICAgIGVkaXRvci5zZXRDdXJzb3IoeyBsaW5lOiBsaW5lVG9SZXR1cm4sIGNoOiBlZGl0b3IuZ2V0TGluZShsaW5lVG9SZXR1cm4pLmxlbmd0aCB9KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbiIsICJpbXBvcnQgeyBFZGl0b3IsIEVkaXRvckNoYW5nZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgZ2V0TGluZUluZm8gfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgTGluZUluZm8sIFJlb3JkZXJSZXN1bHQgfSBmcm9tIFwiLi90eXBlc1wiO1xuaW1wb3J0IFNldHRpbmdzTWFuYWdlciBmcm9tIFwiLi9TZXR0aW5nc01hbmFnZXJcIjtcblxuZnVuY3Rpb24gcmVvcmRlckNoZWNrbGlzdChlZGl0b3I6IEVkaXRvciwgc3RhcnQ6IG51bWJlciwgbGltaXQ/OiBudW1iZXIpOiBSZW9yZGVyUmVzdWx0IHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCByZXN1bHQgPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gcmVvcmRlckF0SW5kZXgoZWRpdG9yLCBzdGFydCkgOiByZW9yZGVyQWxsTGlzdHNJblJhbmdlKGVkaXRvciwgc3RhcnQsIGxpbWl0KTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgeyBjaGFuZ2VzLCByZW9yZGVyUmVzdWx0IH0gPSByZXN1bHQ7XG4gICAgYXBwbHlDaGFuZ2VzVG9FZGl0b3IoZWRpdG9yLCBjaGFuZ2VzKTtcblxuICAgIHJldHVybiByZW9yZGVyUmVzdWx0O1xufVxuXG4vLyByZW51bWJlcnMgYWxsIG51bWJlcmVkIGxpc3RzIGluIHNwZWNpZmllZCByYW5nZVxuZnVuY3Rpb24gcmVvcmRlckFsbExpc3RzSW5SYW5nZShcbiAgICBlZGl0b3I6IEVkaXRvcixcbiAgICBzdGFydDogbnVtYmVyLFxuICAgIGxpbWl0OiBudW1iZXJcbik6IHsgcmVvcmRlclJlc3VsdDogUmVvcmRlclJlc3VsdDsgY2hhbmdlczogRWRpdG9yQ2hhbmdlW10gfSB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgaXNJbnZhbGlkUmFuZ2UgPSBzdGFydCA8IDAgfHwgZWRpdG9yLmxhc3RMaW5lKCkgKyAxIDwgbGltaXQgfHwgbGltaXQgPCBzdGFydDtcbiAgICBjb25zdCBjaGFuZ2VzOiBFZGl0b3JDaGFuZ2VbXSA9IFtdO1xuXG4gICAgbGV0IGkgPSBzdGFydDtcbiAgICBsZXQgY3VycmVudFN0YXJ0OiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gICAgbGV0IGVuZCA9IGk7XG5cbiAgICBpZiAoaXNJbnZhbGlkUmFuZ2UpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIGByZW9yZGVyQWxsTGlzdHNJblJhbmdlIGlzIGludmFsaWQgd2l0aCBpbmRleD0ke3N0YXJ0fSwgbGltaXQ9JHtsaW1pdH0uIGVkaXRvci5sYXN0TGluZSgpPSR7ZWRpdG9yLmxhc3RMaW5lKCl9YFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKDsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgICAgY29uc3QgcmVvcmRlckRhdGEgPSByZW9yZGVyQXRJbmRleChlZGl0b3IsIGkpO1xuXG4gICAgICAgIGlmIChyZW9yZGVyRGF0YSA9PT0gdW5kZWZpbmVkIHx8IHJlb3JkZXJEYXRhLmNoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFuZ2VzLnB1c2goLi4ucmVvcmRlckRhdGEuY2hhbmdlcyk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjdXJyZW50U3RhcnQgPSByZW9yZGVyRGF0YS5yZW9yZGVyUmVzdWx0LnN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgZW5kID0gcmVvcmRlckRhdGEucmVvcmRlclJlc3VsdC5saW1pdDtcbiAgICAgICAgaSA9IGVuZDtcblxuICAgICAgICB3aGlsZSAoc2hvdWxkQmVTb3J0ZWRBc0NoZWNrZWQoZ2V0TGluZUluZm8oZWRpdG9yLmdldExpbmUoaSkpLmNoZWNrYm94Q2hhcikgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZXMubGVuZ3RoID09PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVvcmRlclJlc3VsdDoge1xuICAgICAgICAgICAgc3RhcnQ6IGN1cnJlbnRTdGFydCA/PyBzdGFydCxcbiAgICAgICAgICAgIGxpbWl0OiBlbmQsXG4gICAgICAgIH0sXG4gICAgICAgIGNoYW5nZXMsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcmVvcmRlckF0SW5kZXgoXG4gICAgZWRpdG9yOiBFZGl0b3IsXG4gICAgaW5kZXg6IG51bWJlclxuKTogeyByZW9yZGVyUmVzdWx0OiBSZW9yZGVyUmVzdWx0OyBjaGFuZ2VzOiBFZGl0b3JDaGFuZ2VbXSB9IHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaW5kZXgpO1xuICAgIGNvbnN0IHN0YXJ0SW5mbyA9IGdldExpbmVJbmZvKGxpbmUpO1xuICAgIGNvbnN0IGhhc0NvbnRlbnQgPSBoYXNDaGVja2JveENvbnRlbnQobGluZSk7XG5cbiAgICAvLyBpZiBub3QgYSBjaGVja2JveCBvciB3aXRob3V0IGFueSBjb250ZW50LCBkb250IHJlb3JkZXJcbiAgICBpZiAoc2hvdWxkQmVTb3J0ZWRBc0NoZWNrZWQoc3RhcnRJbmZvLmNoZWNrYm94Q2hhcikgPT09IHVuZGVmaW5lZCB8fCBoYXNDb250ZW50ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hlY2tsaXN0U3RhcnRJbmRleCA9IGdldENoZWNrbGlzdFN0YXJ0KGVkaXRvciwgaW5kZXgpO1xuXG4gICAgY29uc3QgeyBvcmRlcmVkSXRlbXMsIHJlb3JkZXJSZXN1bHQgfSA9IHJlb3JkZXIoZWRpdG9yLCBjaGVja2xpc3RTdGFydEluZGV4LCBzdGFydEluZm8pO1xuXG4gICAgaWYgKG9yZGVyZWRJdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuOyAvLyBubyBjaGFuZ2VzIGFyZSBuZWVkZWRcbiAgICB9XG5cbiAgICBjb25zdCB7IHN0YXJ0OiBzdGFydEluZGV4LCBsaW1pdDogZW5kSW5kZXggfSA9IHJlb3JkZXJSZXN1bHQ7XG5cbiAgICBjb25zdCBuZXdUZXh0ID0gZW5kSW5kZXggPiBlZGl0b3IubGFzdExpbmUoKSA/IG9yZGVyZWRJdGVtcy5qb2luKFwiXFxuXCIpIDogb3JkZXJlZEl0ZW1zLmpvaW4oXCJcXG5cIikgKyBcIlxcblwiOyAvLyBhZGp1c3QgZm9yIHRoZSBsYXN0IGxpbmUgaW4gbm90ZVxuXG4gICAgY29uc3QgY2hhbmdlOiBFZGl0b3JDaGFuZ2UgPSB7XG4gICAgICAgIGZyb206IHsgbGluZTogc3RhcnRJbmRleCwgY2g6IDAgfSxcbiAgICAgICAgdG86IHsgbGluZTogZW5kSW5kZXgsIGNoOiAwIH0sXG4gICAgICAgIHRleHQ6IG5ld1RleHQsXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGNoYW5nZXM6IFtjaGFuZ2VdLFxuICAgICAgICByZW9yZGVyUmVzdWx0OiB7XG4gICAgICAgICAgICBzdGFydDogc3RhcnRJbmRleCxcbiAgICAgICAgICAgIGxpbWl0OiBlbmRJbmRleCxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiByZW9yZGVyKFxuICAgIGVkaXRvcjogRWRpdG9yLFxuICAgIGluZGV4OiBudW1iZXIsXG4gICAgc3RhcnRJbmZvOiBMaW5lSW5mb1xuKTogeyBvcmRlcmVkSXRlbXM6IHN0cmluZ1tdOyByZW9yZGVyUmVzdWx0OiBSZW9yZGVyUmVzdWx0IH0ge1xuICAgIGNvbnN0IGNoZWNrZWRJdGVtc0F0Qm90dG9tID0gU2V0dGluZ3NNYW5hZ2VyLmdldEluc3RhbmNlKCkuaXNDaGVja2VkSXRlbXNBdEJvdHRvbSgpO1xuICAgIGNvbnN0IHVuY2hlY2tlZEl0ZW1zOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IGNoZWNrZWRNYXA6IE1hcDxzdHJpbmcsIFtzdHJpbmcsIExpbmVJbmZvXVtdPiA9IG5ldyBNYXAoKTtcblxuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBmaW5kUmVvcmRlclN0YXJ0UG9zaXRpb24oZWRpdG9yLCBpbmRleCwgc3RhcnRJbmZvLCBjaGVja2VkSXRlbXNBdEJvdHRvbSk7XG5cbiAgICBsZXQgcHJldkNoYXIgPSBcIlwiO1xuICAgIGxldCB0cmFuc2l0aW9uSW5kZXggPSAwO1xuXG4gICAgLy8gcGhhc2UgMSAtIG1hcCBpdGVtc1xuICAgIGxldCBpID0gc3RhcnRJbmRleDtcbiAgICB3aGlsZSAoaSA8PSBlZGl0b3IubGFzdExpbmUoKSkge1xuICAgICAgICBjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSk7XG4gICAgICAgIGNvbnN0IGN1cnJJbmZvID0gZ2V0TGluZUluZm8obGluZSk7XG5cbiAgICAgICAgLy8gU3RvcCBpZiB0aGUgbGluZSBzdGF0dXMgZGlmZmVycyBmcm9tIHRoZSBzdGFydGluZyBncm91cFxuICAgICAgICBpZiAoIWlzU2FtZVN0YXR1cyhzdGFydEluZm8sIGN1cnJJbmZvKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjdXJyZW50Q2hhciA9IGN1cnJJbmZvLmNoZWNrYm94Q2hhcjtcblxuICAgICAgICBpZiAoY3VycmVudENoYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYnJlYWs7IC8vIGlzIG5vdCBhIGNoZWNrZWQgbGluZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBtYXggY2hhciBzbyBmYXJcbiAgICAgICAgaWYgKGN1cnJlbnRDaGFyICE9PSBwcmV2Q2hhcikge1xuICAgICAgICAgICAgcHJldkNoYXIgPSBjdXJyZW50Q2hhcjtcbiAgICAgICAgICAgIHRyYW5zaXRpb25JbmRleCA9IHVuY2hlY2tlZEl0ZW1zLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0byB0aGUgY29ycmVjdCBkYXRhIHN0cnVjdHVyZVxuICAgICAgICBpZiAoc2hvdWxkQmVTb3J0ZWRBc0NoZWNrZWQoY3VycmVudENoYXIpKSB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrZWRNYXAuaGFzKGN1cnJlbnRDaGFyKSkge1xuICAgICAgICAgICAgICAgIGNoZWNrZWRNYXAuc2V0KGN1cnJlbnRDaGFyLCBbXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGVja2VkTWFwLmdldChjdXJyZW50Q2hhcikhLnB1c2goW2xpbmUsIGN1cnJJbmZvXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bmNoZWNrZWRJdGVtcy5wdXNoKGxpbmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIGNvbnN0IGZpbmlzaGVkQXQgPSBpO1xuXG4gICAgLy8gcGhhc2UgMiAtIHNvcnQgY2hlY2tlZCBpdGVtc1xuICAgIGNvbnN0IGNoYXJzVG9EZWxldGUgPSBnZXRDaGFyc1RvRGVsZXRlKCk7IC8vIGRlZmluZWQgYnkgdXNlclxuICAgIGNvbnN0IGNoZWNrZWRJdGVtcyA9IFtdO1xuICAgIGNvbnN0IGNoZWNrZWRJdGVtc0RlbCA9IFtdO1xuICAgIGNvbnN0IGtleXMgPSBBcnJheS5mcm9tKGNoZWNrZWRNYXAua2V5cygpKS5zb3J0KCk7XG4gICAgY29uc3QgS1ZwYWlycyA9IGtleXMuZmxhdE1hcCgoaykgPT4gY2hlY2tlZE1hcC5nZXQoaykhKTtcblxuICAgIGZvciAoY29uc3QgW3MsIGxpbmVJbmZvXSBvZiBLVnBhaXJzKSB7XG4gICAgICAgIGlmICghbGluZUluZm8uY2hlY2tib3hDaGFyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFyc1RvRGVsZXRlLmhhcyhsaW5lSW5mby5jaGVja2JveENoYXIpKSB7XG4gICAgICAgICAgICBjaGVja2VkSXRlbXNEZWwucHVzaChzKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaG91bGRCZVNvcnRlZEFzQ2hlY2tlZChsaW5lSW5mby5jaGVja2JveENoYXIpKSB7XG4gICAgICAgICAgICBjaGVja2VkSXRlbXMucHVzaChzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrZWRJdGVtcy5wdXNoKC4uLmNoZWNrZWRJdGVtc0RlbCk7XG5cbiAgICAvLyBwaGFzZSAzIC0gY29tYmluZSBhbmQgcmVtb3ZlIHVuY2hhbmdlZCBsaW5lc1xuICAgIGlmICghY2hlY2tlZEl0ZW1zQXRCb3R0b20pIHtcbiAgICAgICAgdW5jaGVja2VkSXRlbXMuc3BsaWNlKHRyYW5zaXRpb25JbmRleCk7IC8vIHJlbW92ZSB1bmNoYW5nZWQgdW5jaGVja2VkIGxpbmVzIGZyb20gdGhlIGVuZFxuICAgIH1cblxuICAgIGNvbnN0IG9yZGVyZWRJdGVtcyA9IGNoZWNrZWRJdGVtc0F0Qm90dG9tXG4gICAgICAgID8gWy4uLnVuY2hlY2tlZEl0ZW1zLCAuLi5jaGVja2VkSXRlbXNdXG4gICAgICAgIDogWy4uLmNoZWNrZWRJdGVtcywgLi4udW5jaGVja2VkSXRlbXNdO1xuXG4gICAgLy8gcmVtb3ZlIHVuY2hhbmdlZCBsaW5lcyBmcm9tIHRoZSBiZWdpbm5pbmdcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAoOyBjb3VudCA8IG9yZGVyZWRJdGVtcy5sZW5ndGg7IGNvdW50KyspIHtcbiAgICAgICAgaWYgKG9yZGVyZWRJdGVtc1tjb3VudF0gIT09IGVkaXRvci5nZXRMaW5lKHN0YXJ0SW5kZXggKyBjb3VudCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3JkZXJlZEl0ZW1zLnNwbGljZSgwLCBjb3VudCk7XG5cbiAgICBjb25zdCBuZXdTdGFydCA9IHN0YXJ0SW5kZXggKyBjb3VudDtcblxuICAgIC8vIHJlbW92ZSB1bmNoYW5nZWQgbGluZXMgZnJvbSB0aGUgZW5kXG4gICAgY29uc3Qgb2Zmc2V0dGVkU3RhcnQgPSBmaW5pc2hlZEF0IC0gKG9yZGVyZWRJdGVtcy5sZW5ndGggLSAxKSAtIDE7XG4gICAgZm9yIChsZXQgaSA9IG9yZGVyZWRJdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAob3JkZXJlZEl0ZW1zW2ldICE9PSBlZGl0b3IuZ2V0TGluZShvZmZzZXR0ZWRTdGFydCArIGkpKSB7XG4gICAgICAgICAgICBvcmRlcmVkSXRlbXMuc3BsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3JkZXJlZEl0ZW1zLFxuICAgICAgICByZW9yZGVyUmVzdWx0OiB7XG4gICAgICAgICAgICBzdGFydDogbmV3U3RhcnQsXG4gICAgICAgICAgICBsaW1pdDogbmV3U3RhcnQgKyBvcmRlcmVkSXRlbXMubGVuZ3RoLFxuICAgICAgICB9LFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldENoZWNrbGlzdFN0YXJ0KGVkaXRvcjogRWRpdG9yLCBpbmRleDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0SW5mbyA9IGdldExpbmVJbmZvKGVkaXRvci5nZXRMaW5lKGluZGV4KSk7XG4gICAgbGV0IGkgPSBpbmRleCAtIDE7XG5cbiAgICB3aGlsZSAoMCA8PSBpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJJbmZvID0gZ2V0TGluZUluZm8oZWRpdG9yLmdldExpbmUoaSkpO1xuICAgICAgICBpZiAoIWlzU2FtZVN0YXR1cyhzdGFydEluZm8sIGN1cnJJbmZvKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaS0tO1xuICAgIH1cblxuICAgIHJldHVybiBpICsgMTtcbn1cblxuZnVuY3Rpb24gZmluZFJlb3JkZXJTdGFydFBvc2l0aW9uKFxuICAgIGVkaXRvcjogRWRpdG9yLFxuICAgIHN0YXJ0SW5kZXg6IG51bWJlcixcbiAgICBzdGFydEluZm86IExpbmVJbmZvLFxuICAgIGNoZWNrZWRJdGVtc0F0Qm90dG9tOiBib29sZWFuXG4pOiBudW1iZXIge1xuICAgIGlmICghY2hlY2tlZEl0ZW1zQXRCb3R0b20pIHtcbiAgICAgICAgcmV0dXJuIHN0YXJ0SW5kZXg7XG4gICAgfVxuXG4gICAgbGV0IGkgPSBzdGFydEluZGV4O1xuICAgIHdoaWxlIChpIDw9IGVkaXRvci5sYXN0TGluZSgpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJJbmZvID0gZ2V0TGluZUluZm8oZWRpdG9yLmdldExpbmUoaSkpO1xuICAgICAgICBpZiAoc2hvdWxkQmVTb3J0ZWRBc0NoZWNrZWQoY3VyckluZm8uY2hlY2tib3hDaGFyKSAhPT0gZmFsc2UgfHwgIWlzU2FtZVN0YXR1cyhzdGFydEluZm8sIGN1cnJJbmZvKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiBpO1xufVxuXG4vLyBTdGF0dXMgPSBCb3RoIGxpbmVzIGFyZSBudW1iZXJlZCBcXCB1bm51bWJlcmVkXG5mdW5jdGlvbiBpc1NhbWVTdGF0dXMoaW5mbzE6IExpbmVJbmZvLCBpbmZvMjogTGluZUluZm8pOiBib29sZWFuIHtcbiAgICBjb25zdCBoYXNTYW1lTnVtYmVyU3RhdHVzID0gKGluZm8xLm51bWJlciAhPT0gdW5kZWZpbmVkKSA9PT0gKGluZm8yLm51bWJlciAhPT0gdW5kZWZpbmVkKTtcbiAgICBjb25zdCBoYXNTYW1lSW5kZW50YXRpb24gPSBpbmZvMS5zcGFjZUluZGVudCA9PT0gaW5mbzIuc3BhY2VJbmRlbnQ7XG4gICAgY29uc3QgaGFzU2FtZUNoZWNrYm94U3RhdHVzID1cbiAgICAgICAgKHNob3VsZEJlU29ydGVkQXNDaGVja2VkKGluZm8xLmNoZWNrYm94Q2hhcikgIT09IHVuZGVmaW5lZCkgPT09XG4gICAgICAgIChzaG91bGRCZVNvcnRlZEFzQ2hlY2tlZChpbmZvMi5jaGVja2JveENoYXIpICE9PSB1bmRlZmluZWQpO1xuXG4gICAgaWYgKGhhc1NhbWVOdW1iZXJTdGF0dXMgJiYgaGFzU2FtZUluZGVudGF0aW9uICYmIGhhc1NhbWVDaGVja2JveFN0YXR1cykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGRlbGV0ZUNoZWNrZWQoZWRpdG9yOiBFZGl0b3IpOiB7IGRlbGV0ZVJlc3VsdDogUmVvcmRlclJlc3VsdDsgZGVsZXRlZEl0ZW1Db3VudDogbnVtYmVyIH0ge1xuICAgIGNvbnN0IGxhc3RMaW5lID0gZWRpdG9yLmxhc3RMaW5lKCk7XG4gICAgY29uc3QgY2hhbmdlczogRWRpdG9yQ2hhbmdlW10gPSBbXTtcbiAgICBjb25zdCBjaGFyc1RvRGVsZXRlID0gZ2V0Q2hhcnNUb0RlbGV0ZSgpO1xuXG4gICAgbGV0IGRlbGV0ZWRJdGVtQ291bnQgPSAwO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBsYXN0TGluZTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJMaW5lID0gZ2V0TGluZUluZm8oZWRpdG9yLmdldExpbmUoaSkpO1xuXG4gICAgICAgIGlmIChjdXJyTGluZS5jaGVja2JveENoYXIgIT09IHVuZGVmaW5lZCAmJiBjaGFyc1RvRGVsZXRlLmhhcyhjdXJyTGluZS5jaGVja2JveENoYXIudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gaTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBmcm9tOiB7IGxpbmU6IGksIGNoOiAwIH0sXG4gICAgICAgICAgICAgICAgdG86IHsgbGluZTogaSArIDEsIGNoOiAwIH0sXG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgZGVsZXRlZEl0ZW1Db3VudCsrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXBwbHlDaGFuZ2VzVG9FZGl0b3IoZWRpdG9yLCBjaGFuZ2VzKTtcblxuICAgIC8vIGxhc3QgbGluZSBpcyBkb25lIHNlcGFyYXRlbHkgYmVjYXN1ZSBpdCBoYXMgbm8gbmV3IGxpbmUgYWZ0ZXIgaXRcbiAgICBpZiAoZW5kID09PSBsYXN0TGluZSAmJiBlbmQgIT09IDApIHtcbiAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gZWRpdG9yLmxhc3RMaW5lKCk7XG4gICAgICAgIGlmIChsYXN0SW5kZXggPiAwKSB7XG4gICAgICAgICAgICBlZGl0b3IucmVwbGFjZVJhbmdlKFxuICAgICAgICAgICAgICAgIFwiXCIsXG4gICAgICAgICAgICAgICAgeyBsaW5lOiBsYXN0SW5kZXggLSAxLCBjaDogZWRpdG9yLmdldExpbmUobGFzdEluZGV4IC0gMSkubGVuZ3RoIH0sXG4gICAgICAgICAgICAgICAgeyBsaW5lOiBsYXN0SW5kZXgsIGNoOiAwIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBsaW1pdCA9IGVuZCArIDEgLSBkZWxldGVkSXRlbUNvdW50OyAvLyAgaW5kZXggYWZ0ZXIgdGhlIGxhc3QgZGVsZXRlZCBsaW5lXG5cbiAgICByZXR1cm4geyBkZWxldGVSZXN1bHQ6IHsgc3RhcnQsIGxpbWl0IH0sIGRlbGV0ZWRJdGVtQ291bnQgfTtcbn1cblxuLy8gY2hhciBzaG91bGQgYmUgdHJlYXRlZCBhcyBjaGVja2VkXG5mdW5jdGlvbiBzaG91bGRCZVNvcnRlZEFzQ2hlY2tlZChjaGFyOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBib29sZWFuIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoY2hhciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc29ydFNwZWNpYWxDaGFycyA9IFNldHRpbmdzTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldFNvcnRTcGVjaWFsQ2hhcnMoKTtcbiAgICBjb25zdCBjaGVja2VkSXRlbXMgPSBnZXRDaGFyc1RvRGVsZXRlKCk7XG4gICAgY29uc3QgaXNTcGVjaWFsQ2hhciA9IGNoYXIgIT09IFwiIFwiO1xuXG4gICAgaWYgKChpc1NwZWNpYWxDaGFyICYmIHNvcnRTcGVjaWFsQ2hhcnMpIHx8IGNoZWNrZWRJdGVtcy5oYXMoY2hhcikpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRDaGFyc1RvRGVsZXRlKCk6IFNldDxzdHJpbmc+IHtcbiAgICBjb25zdCB2YWx1ZSA9IFNldHRpbmdzTWFuYWdlci5nZXRJbnN0YW5jZSgpLmdldENoYXJzVG9EZWxldGUoKTtcbiAgICBjb25zdCBkZWZhdWx0RGVsZXRlID0gW1wieFwiXTtcbiAgICBjb25zdCBmaWx0ZXJDaGFycyA9IHZhbHVlXG4gICAgICAgIC50cmltKClcbiAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgLnNwbGl0KFwiIFwiKVxuICAgICAgICAuZmlsdGVyKChjaGFyKSA9PiBjaGFyLmxlbmd0aCA9PT0gMSk7XG5cbiAgICBjb25zdCBjaGFyc1RvRGVsZXRlID0gbmV3IFNldChbLi4uZGVmYXVsdERlbGV0ZSwgLi4uZmlsdGVyQ2hhcnNdKTtcblxuICAgIHJldHVybiBjaGFyc1RvRGVsZXRlO1xufVxuXG4vLyBpcyBhIHBhcnQgb2YgYSBjaGVja2xpc3QsIGFuZCBub3QgYW4gZW1wdHkgaXRlbVxuZnVuY3Rpb24gaGFzQ2hlY2tib3hDb250ZW50KGxpbmU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IENIRUNLQk9YX1dJVEhfQ09OVEVOVCA9IC9eKD86XFxzKlxcZCtcXC5cXHMqXFxbLlxcXXxcXHMqLVxccypcXFsuXFxdKVxccytcXFMrLztcbiAgICByZXR1cm4gQ0hFQ0tCT1hfV0lUSF9DT05URU5ULnRlc3QobGluZSk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5Q2hhbmdlc1RvRWRpdG9yKGVkaXRvcjogRWRpdG9yLCBjaGFuZ2VzOiBFZGl0b3JDaGFuZ2VbXSkge1xuICAgIGlmIChjaGFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZWRpdG9yLnRyYW5zYWN0aW9uKHsgY2hhbmdlcyB9KTtcbiAgICB9XG59XG5leHBvcnQgeyByZW9yZGVyQ2hlY2tsaXN0LCByZW9yZGVyLCBnZXRDaGVja2xpc3RTdGFydCwgZGVsZXRlQ2hlY2tlZCB9O1xuIiwgImltcG9ydCB7IEVkaXRvciwgRWRpdG9yQ2hhbmdlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBnZXRMaXN0U3RhcnQsIGdldExpbmVJbmZvLCBnZXRQcmV2SXRlbUluZGV4IH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IENoYW5nZVJlc3VsdCwgTGluZUluZm8sIFBlbmRpbmdDaGFuZ2VzIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCBTZXR0aW5nc01hbmFnZXIgZnJvbSBcIi4vU2V0dGluZ3NNYW5hZ2VyXCI7XG5cbi8vIHJlc3BvbnNpYmxlIGZvciBhbGwgcmVudW1iZXJpbmcgYWN0aW9uc1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVudW1iZXJlciB7XG4gICAgcmVudW1iZXIoZWRpdG9yOiBFZGl0b3IsIHN0YXJ0OiBudW1iZXIsIGxpbWl0PzogbnVtYmVyKSB7XG4gICAgICAgIGxldCBwZW5kaW5nQ2hhbmdlcztcblxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCB8fCBsaW1pdCA9PT0gc3RhcnQpIHtcbiAgICAgICAgICAgIHBlbmRpbmdDaGFuZ2VzID0gdGhpcy5yZW51bWJlckF0SW5kZXgoZWRpdG9yLCBzdGFydCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZW5kaW5nQ2hhbmdlcyA9IHRoaXMucmVudW1iZXJBbGxMaXN0c0luUmFuZ2UoZWRpdG9yLCBzdGFydCwgbGltaXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hcHBseUNoYW5nZXNUb0VkaXRvcihlZGl0b3IsIHBlbmRpbmdDaGFuZ2VzLmNoYW5nZXMpO1xuICAgICAgICByZXR1cm4gcGVuZGluZ0NoYW5nZXMuZW5kSW5kZXg7XG4gICAgfVxuXG4gICAgLy8gcmVudW1iZXJzIGFsbCBudW1iZXJlZCBsaXN0cyBpbiBzcGVjaWZpZWQgcmFuZ2VcbiAgICBwcml2YXRlIHJlbnVtYmVyQWxsTGlzdHNJblJhbmdlID0gKGVkaXRvcjogRWRpdG9yLCBzdGFydDogbnVtYmVyLCBsaW1pdDogbnVtYmVyKTogUGVuZGluZ0NoYW5nZXMgPT4ge1xuICAgICAgICBjb25zdCBpc0ludmFsaWRSYW5nZSA9IHN0YXJ0IDwgMCB8fCBsaW1pdCA8IHN0YXJ0O1xuICAgICAgICBjb25zdCBlZGl0b3JMYXN0TGluZSA9IGVkaXRvci5sYXN0TGluZSgpO1xuICAgICAgICBjb25zdCBuZXdDaGFuZ2VzOiBFZGl0b3JDaGFuZ2VbXSA9IFtdO1xuXG4gICAgICAgIGlmIChpc0ludmFsaWRSYW5nZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgSW52YWxpZCByZW51bWJlcmluZyByYW5nZTogc3RhcnQ9JHtzdGFydH0sIGxpbWl0PSR7bGltaXR9LiBSZXF1aXJlcyAoMCA8PSBzdGFydCA8PSBsaW1pdCkuYCk7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBuZXdDaGFuZ2VzLCBlbmRJbmRleDogc3RhcnQgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlZGl0b3JMYXN0TGluZSArIDEgPCBsaW1pdCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICBgTGltaXQgZXhjZWVkcyBkb2N1bWVudCBib3VuZHM6IGF0dGVtcHRlZCBsaW1pdD0ke2xpbWl0fSwgYWN0dWFsIGxpbWl0PSR7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvckxhc3RMaW5lICsgMVxuICAgICAgICAgICAgICAgIH0uIEFkanVzdGluZyBsaW1pdC5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbGltaXQgPSBlZGl0b3JMYXN0TGluZSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaSA9IHN0YXJ0O1xuICAgICAgICBmb3IgKDsgaSA8IGxpbWl0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpKTtcblxuICAgICAgICAgICAgaWYgKGxpbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB7IG51bWJlciB9ID0gZ2V0TGluZUluZm8obGluZSk7XG5cbiAgICAgICAgICAgIGlmIChudW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gZ2V0TGlzdFN0YXJ0KGVkaXRvciwgaSk7XG5cbiAgICAgICAgICAgIGlmIChzdGFydEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nQ2hhbmdlcyA9IHRoaXMucmVudW1iZXJBdEluZGV4KGVkaXRvciwgc3RhcnRJbmRleCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICBuZXdDaGFuZ2VzLnB1c2goLi4ucGVuZGluZ0NoYW5nZXMuY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBwZW5kaW5nQ2hhbmdlcy5lbmRJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBuZXdDaGFuZ2VzLCBlbmRJbmRleDogaSB9O1xuICAgIH07XG5cbiAgICAvLyBiZnMgd2hlcmUgaW5kZW50cyA9PSBqdW5jdGlvbnNcbiAgICBwcml2YXRlIHJlbnVtYmVyQXRJbmRleChlZGl0b3I6IEVkaXRvciwgaW5kZXg6IG51bWJlciwgaXNMb2NhbCA9IHRydWUpOiBQZW5kaW5nQ2hhbmdlcyB7XG4gICAgICAgIGNvbnN0IGNoYW5nZXM6IEVkaXRvckNoYW5nZVtdID0gW107XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gW2luZGV4XTsgLy8gY29udGFpbnMgaW5kaWNlcyB0byByZXZpc2l0XG4gICAgICAgIGxldCBlbmRJbmRleCA9IGluZGV4O1xuXG4gICAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgIHF1ZXVlLnVuc2hpZnQoaW5kZXggLSAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbmRleCA8IGVkaXRvci5sYXN0TGluZSgpKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGluZGV4ICsgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2aXNpdGVkOiBudW1iZXJbXSA9IFtdOyAvLyB2aXNpdGVkW3NwYWNlSW5kZW50XSA9PSBsYXN0VmlzaXRlZEluZGV4XG4gICAgICAgIGNvbnN0IGZpcnN0U3BhY2VJbmRlbnQgPSBnZXRMaW5lSW5mbyhlZGl0b3IuZ2V0TGluZShxdWV1ZVswXSkpLnNwYWNlSW5kZW50O1xuICAgICAgICB2aXNpdGVkW2ZpcnN0U3BhY2VJbmRlbnRdID0gcXVldWVbMF07XG5cbiAgICAgICAgd2hpbGUgKDAgPCBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4VG9SZW51bWJlciA9IHF1ZXVlLnNoaWZ0KCkhO1xuICAgICAgICAgICAgaWYgKGluZGV4VG9SZW51bWJlciA+IGVkaXRvci5sYXN0TGluZSgpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpbmZvID0gZ2V0TGluZUluZm8oZWRpdG9yLmdldExpbmUoaW5kZXhUb1JlbnVtYmVyKSk7XG4gICAgICAgICAgICBpZiAoaW5kZXhUb1JlbnVtYmVyIDwgdmlzaXRlZFtpbmZvLnNwYWNlSW5kZW50XSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgaW5kZW50YXRpb24gaGFzIGJlZW4gdmlzaXRlZCBhbmQgaXRzIHRoaXMgaW5kZXggaGFkIGFscmVhZHkgYmVlbiByZW51bWJlcmVkXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpbmZvLm51bWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHByZXZJbmRleCA9IGdldFByZXZJdGVtSW5kZXgoZWRpdG9yLCBpbmRleFRvUmVudW1iZXIpO1xuICAgICAgICAgICAgY29uc3QgaXNTdGFydEZyb21PbmUgPSBTZXR0aW5nc01hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXRTdGFydHNGcm9tT25lKCk7XG5cbiAgICAgICAgICAgIGxldCBudW06IG51bWJlcjtcbiAgICAgICAgICAgIGlmIChwcmV2SW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG51bSA9IGlzU3RhcnRGcm9tT25lID8gMSA6IGluZm8ubnVtYmVyOyAvLyBpcyB0aGUgZmlyc3QgaXRlbSBudW1iZXIgaW4gdGhlIGxpc3RcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbnVtID0gZ2V0TGluZUluZm8oZWRpdG9yLmdldExpbmUocHJldkluZGV4KSkubnVtYmVyISArIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZVJlc3VsdCA9IHRoaXMuZ2VuZXJhdGVDaGFuZ2VzKGVkaXRvciwgaW5kZXhUb1JlbnVtYmVyLCBudW0sIGluZm8uc3BhY2VJbmRlbnQsIGlzTG9jYWwpO1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKC4uLmNoYW5nZVJlc3VsdC5jaGFuZ2VzKTtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goLi4uY2hhbmdlUmVzdWx0LnJldmlzaXRJbmRpY2VzKTtcblxuICAgICAgICAgICAgdmlzaXRlZFtpbmZvLnNwYWNlSW5kZW50XSA9IGNoYW5nZVJlc3VsdC5lbmRJbmRleDtcbiAgICAgICAgICAgIGVuZEluZGV4ID0gTWF0aC5tYXgoZW5kSW5kZXgsIGNoYW5nZVJlc3VsdC5lbmRJbmRleCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzLCBlbmRJbmRleCB9O1xuICAgIH1cblxuICAgIC8vIHBlcmZvcm1zIHRoZSBjYWxjdWxhdGlvbiBpdHNlbGZcbiAgICBwcml2YXRlIGdlbmVyYXRlQ2hhbmdlcyhcbiAgICAgICAgZWRpdG9yOiBFZGl0b3IsXG4gICAgICAgIGZpcnN0SW5kZXg6IG51bWJlcixcbiAgICAgICAgY3VycmVudE51bWJlcjogbnVtYmVyLFxuICAgICAgICBmaXJzdEluZGVudDogbnVtYmVyLFxuICAgICAgICBpc0xvY2FsID0gdHJ1ZVxuICAgICk6IENoYW5nZVJlc3VsdCB7XG4gICAgICAgIGNvbnN0IHJldmlzaXRJbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xuICAgICAgICBjb25zdCBjaGFuZ2VzOiBFZGl0b3JDaGFuZ2VbXSA9IFtdO1xuICAgICAgICBsZXQgZmlyc3RNYXRjaEluU3VjY2Vzc2lvbiA9IHRydWU7XG5cbiAgICAgICAgaWYgKGZpcnN0SW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzLCByZXZpc2l0SW5kaWNlcywgZW5kSW5kZXg6IGZpcnN0SW5kZXggfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjdXJyZW50SW5kZXggPSBmaXJzdEluZGV4O1xuICAgICAgICBsZXQgaW5kZXhUb1JldmlzaXQgPSB0cnVlOyAvLyB0cnVlIGlmIHRoZSBmaXJzdCBsaW5lIHdpdGggaGlnaGVyIGluZGVudCBuZWVkcyB0byBiZSByZXZpc2l0ZWQsIGZhbHNlIG8udy5cbiAgICAgICAgZm9yICg7IGN1cnJlbnRJbmRleCA8PSBlZGl0b3IubGFzdExpbmUoKTsgY3VycmVudEluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVUZXh0ID0gZWRpdG9yLmdldExpbmUoY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSBnZXRMaW5lSW5mbyhsaW5lVGV4dCk7XG5cbiAgICAgICAgICAgIC8vIGlmIG9uIGEgaGlnaGVyIGluZGVudCwgYWRkIGl0J3MgZmlyc3QgaW5kZXggdG8gdGhlIHRoZSBxdWV1ZSB0byByZXZpc2l0XG4gICAgICAgICAgICBpZiAoaW5mby5zcGFjZUluZGVudCA+IGZpcnN0SW5kZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4VG9SZXZpc2l0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldmlzaXRJbmRpY2VzLnB1c2goY3VycmVudEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhUb1JldmlzaXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIG9uIGEgbG93ZXIgaW5kZW50LCBhZGQgaXQgYXMgYSBqdW5jdGlvbiBhbmQgYnJlYWtcbiAgICAgICAgICAgIGlmIChpbmZvLnNwYWNlSW5kZW50IDwgZmlyc3RJbmRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXZpc2l0SW5kaWNlcy5wdXNoKGN1cnJlbnRJbmRleCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGluZGV4VG9SZXZpc2l0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gaWYgbm90IGEgbnVtYmVyIG9yIG9uIGEgbG93ZXIgaW5kZW50XG4gICAgICAgICAgICBpZiAoaW5mby5udW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBhbHJlYWR5IGVxdWFsIHRvIHRoZSBjdXJyZW50IGxpbmUsIG5vIG5lZWQgdG8gdXBkYXRlXG4gICAgICAgICAgICBpZiAoaW5mby5udW1iZXIgPT09IGN1cnJlbnROdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpc0xvY2FsIGFuZCB0aGVyZSBhcmUgMiBtYXRjaGVzIGluIGEgcm93LCBicmVha1xuICAgICAgICAgICAgICAgIGlmIChpc0xvY2FsICYmIGZpcnN0TWF0Y2hJblN1Y2Nlc3Npb24gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmlyc3RNYXRjaEluU3VjY2Vzc2lvbiA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgY3VycmVudE51bWJlcisrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlyc3RNYXRjaEluU3VjY2Vzc2lvbiA9IHRydWU7IC8vIGlmIG5vIG1hdGNoIHdhcyBmb3VuZCwgc2V0IHRoZSBmbGFnIHRvIHRydWUsIHNvIHR3byBtYXRjaGVzIGluIGEgcm93IGNvdWxkIGJlIGRldGVjdGVkXG5cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRMaW5lID0gdGhpcy5nZXRVcGRhdGVkTGluZShjdXJyZW50SW5kZXgsIGN1cnJlbnROdW1iZXIsIGluZm8sIGxpbmVUZXh0KTtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh1cGRhdGVkTGluZSk7XG4gICAgICAgICAgICBjdXJyZW50TnVtYmVyKys7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4geyBjaGFuZ2VzLCByZXZpc2l0SW5kaWNlcywgZW5kSW5kZXg6IGN1cnJlbnRJbmRleCB9O1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0VXBkYXRlZExpbmUoaW5kZXg6IG51bWJlciwgZXhwZWN0ZWROdW06IG51bWJlciwgaW5mbzogTGluZUluZm8sIHRleHQ6IHN0cmluZyk6IEVkaXRvckNoYW5nZSB7XG4gICAgICAgIGNvbnN0IG5ld1RleHQgPSBgJHt0ZXh0LnNsaWNlKDAsIGluZm8uc3BhY2VDaGFyc051bSl9JHtleHBlY3RlZE51bX0uICR7dGV4dC5zbGljZShpbmZvLnRleHRPZmZzZXQpfWA7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRMaW5lID0ge1xuICAgICAgICAgICAgZnJvbTogeyBsaW5lOiBpbmRleCwgY2g6IDAgfSxcbiAgICAgICAgICAgIHRvOiB7IGxpbmU6IGluZGV4LCBjaDogdGV4dC5sZW5ndGggfSxcbiAgICAgICAgICAgIHRleHQ6IG5ld1RleHQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB1cGRhdGVkTGluZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFwcGx5Q2hhbmdlc1RvRWRpdG9yKGVkaXRvcjogRWRpdG9yLCBjaGFuZ2VzOiBFZGl0b3JDaGFuZ2VbXSkge1xuICAgICAgICBpZiAoY2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBlZGl0b3IudHJhbnNhY3Rpb24oeyBjaGFuZ2VzIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwgImltcG9ydCB7IEFwcCwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZyB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IEF1dG9SZW9yZGVyaW5nIGZyb20gXCIuLi9tYWluXCI7XG5pbXBvcnQgU2V0dGluZ3NNYW5hZ2VyIGZyb20gXCIuL1NldHRpbmdzTWFuYWdlclwiO1xuaW1wb3J0IFwic3R5bGVzLmNzc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBdXRvUmVudW1iZXJpbmdTZXR0aW5ncyBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuICAgIHBsdWdpbjogQXV0b1Jlb3JkZXJpbmc7XG4gICAgc2V0dGluZ3NNYW5hZ2VyOiBTZXR0aW5nc01hbmFnZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBBdXRvUmVvcmRlcmluZykge1xuICAgICAgICBzdXBlcihhcHAsIHBsdWdpbik7XG4gICAgICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICAgICAgICB0aGlzLnNldHRpbmdzTWFuYWdlciA9IFNldHRpbmdzTWFuYWdlci5nZXRJbnN0YW5jZSgpO1xuICAgIH1cblxuICAgIGRpc3BsYXkoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHsgY29udGFpbmVyRWwgfSA9IHRoaXM7XG5cbiAgICAgICAgY29udGFpbmVyRWwuZW1wdHkoKTtcblxuICAgICAgICBjb25zdCBnaXRodWJFbCA9IGNyZWF0ZUZyYWdtZW50KCk7XG4gICAgICAgIGdpdGh1YkVsLmFwcGVuZFRleHQoXCJGb3IgbW9yZSBpbmZvcm1hdGlvbiwgdmlzaXQgXCIpO1xuICAgICAgICBnaXRodWJFbC5jcmVhdGVFbChcImFcIiwge1xuICAgICAgICAgICAgaHJlZjogXCJodHRwczovL2dpdGh1Yi5jb20vT21yaUxldmlHaXQvQXV0by1MaXN0LU1hbmFnZW1lbnQtT2JzaWRpYW5cIixcbiAgICAgICAgICAgIHRleHQ6IFwiR2l0aHViXCIsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGdpdGh1YkVsLmFwcGVuZFRleHQoXCIuXCIpO1xuICAgICAgICBjb250YWluZXJFbC5hcHBlbmRDaGlsZChnaXRodWJFbCk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldEhlYWRpbmcoKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiVGFiIHNpemVcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFxuICAgICAgICAgICAgICAgIFwiU2V0IHRoZSBpbmRlbnQgc2l6ZSB0byB0aGUgc2FtZSBzaXplIGFzIGluIHRoZSBlZGl0b3IncyBzZXR0aW5ncy4gQ2FuIGJlIGZvdW5kIHVuZGVyOiBPcHRpb25zID4gRWRpdG9yID4gVGFiIGluZGVudCBzaXplL0luZGVudCB2aXN1YWwgd2lkdGguXCJcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5hZGRTbGlkZXIoKHNsaWRlcikgPT4ge1xuICAgICAgICAgICAgICAgIHNsaWRlclxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5zZXR0aW5nc01hbmFnZXIuZ2V0SW5kZW50U2l6ZSgpKVxuICAgICAgICAgICAgICAgICAgICAuc2V0TGltaXRzKDIsIDgsIDEpXG4gICAgICAgICAgICAgICAgICAgIC5zZXREeW5hbWljVG9vbHRpcCgpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NNYW5hZ2VyLnNldEluZGVudFNpemUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldEhlYWRpbmcoKS5zZXROYW1lKFwiQ2hlY2tsaXN0c1wiKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiQXV0by1zb3J0IG9uIGNoYW5nZXNcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiQXV0b21hdGljYWxseSBzb3J0IGNoZWNrbGlzdHMgd2hlbmV2ZXIgY2hlY2tib3hlcyBhcmUgY2hlY2tlZCBvciB1bmNoZWNrZWQuXCIpXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+XG4gICAgICAgICAgICAgICAgdG9nZ2xlLnNldFZhbHVlKHRoaXMuc2V0dGluZ3NNYW5hZ2VyLmdldExpdmVDaGVja2JveFVwZGF0ZSgpKS5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nc01hbmFnZXIuc2V0TGl2ZUNoZWNrYm94VXBkYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZShcIlBsYWNlIGNoZWNrZWQgaXRlbXMgYXQgYm90dG9tXCIpXG4gICAgICAgICAgICAuc2V0RGVzYyhcbiAgICAgICAgICAgICAgICBcIldoZW4gZW5hYmxlZCwgY2hlY2tlZCB0YXNrcyB3aWxsIGJlIHBsYWNlZCBhdCB0aGUgYm90dG9tLiBXaGVuIGRpc2FibGVkLCB0aGV5IHdpbGwgYmUgYXQgdGhlIHRvcC5cIlxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PlxuICAgICAgICAgICAgICAgIHRvZ2dsZS5zZXRWYWx1ZSh0aGlzLnNldHRpbmdzTWFuYWdlci5pc0NoZWNrZWRJdGVtc0F0Qm90dG9tKCkpLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzTWFuYWdlci5zZXRDaGVja2VkSXRlbXNBdEJvdHRvbSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IGRlc2NFbCA9IGNyZWF0ZUZyYWdtZW50KCk7XG4gICAgICAgIGRlc2NFbC5hcHBlbmRUZXh0KFwiV2hlbiBlbmFibGVkLCB0YXNrcyB3aXRoIGFueSBzcGVjaWFsIGNoZWNrYm94IGNoYXJhY3RlcnMgd2lsbCBiZSBzb3J0ZWQgYWNjb3JkaW5nIHRvIFwiKTtcbiAgICAgICAgZGVzY0VsLmNyZWF0ZUVsKFwiYVwiLCB7XG4gICAgICAgICAgICBocmVmOiBcImh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FTQ0lJXCIsXG4gICAgICAgICAgICB0ZXh0OiBcIkFTQ0lJXCIsXG4gICAgICAgIH0pO1xuICAgICAgICBkZXNjRWwuYXBwZW5kVGV4dChcIi4gV2hlbiBkaXNhYmxlZCwgb25seSB0YXNrcyBtYXJrZWQgZm9yIGRlbGV0aW9uIHdpbGwgYmUgc29ydGVkLlwiKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiU29ydCBhbGwgc3BlY2lhbCBjaGVja2JveGVzXCIpXG4gICAgICAgICAgICAuc2V0RGVzYyhkZXNjRWwpXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+XG4gICAgICAgICAgICAgICAgdG9nZ2xlLnNldFZhbHVlKHRoaXMuc2V0dGluZ3NNYW5hZ2VyLmdldFNvcnRTcGVjaWFsQ2hhcnMoKSkub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NNYW5hZ2VyLnNldFNvcnRTcGVjaWFsQ2hhcnModmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiQ2hlY2tib3ggZGVsZXRlLWNoYXJhY3RlcnNcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFxuICAgICAgICAgICAgICAgIFwiU3BlY2lmeSB3aGljaCBjaGVja2JveCBjaGFyYWN0ZXJzIG1hcmsgdGFza3MgZm9yIGRlbGV0aW9uLiBUYXNrcyB3aXRoIHRoZXNlIGNoYXJhY3RlcnMgYXJlIGFsd2F5cyBzb3J0ZWQgYmVsb3cgdGFza3Mgd2l0aCBvdGhlciBjaGFyYWN0ZXJzLCBhbmQgY2FuIGJlIHJlbW92ZWQgYnkgdXNpbmcgdGhlIGRlbGV0ZSBjb21tYW5kLlwiXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIHRleHQuc2V0UGxhY2Vob2xkZXIoXCJFbnRlciBjaGFyYWN0ZXJzXCIpXG4gICAgICAgICAgICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnNldHRpbmdzTWFuYWdlci5nZXRDaGFyc1RvRGVsZXRlKCkpXG4gICAgICAgICAgICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NNYW5hZ2VyLnNldENoYXJzVG9EZWxldGUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgY29udGFpbmVyRWwuY3JlYXRlRWwoXCJkaXZcIiwge1xuICAgICAgICAgICAgdGV4dDogXCJFbnRlciBzaW5nbGUgY2hhcmFjdGVycyBzZXBhcmF0ZWQgYnkgc3BhY2VzIChjYXNlLWluc2Vuc2l0aXZlKS4gRGVmYXVsdDogJ1gnLlwiLFxuICAgICAgICAgICAgY2xzOiBcInNldHRpbmctaXRlbS1kZXNjcmlwdGlvblwiLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb250YWluZXJFbC5jcmVhdGVFbChcImRpdlwiLCB7XG4gICAgICAgICAgICB0ZXh0OiBcIkV4YW1wbGU6ICctIC8nIG1lYW5zIHRhc2tzIHdpdGggW3hdLCBbLV0sIG9yIFsvXSB3aWxsIGJlIHJlbW92ZWQsIHdoaWxlIHRhc2tzIHdpdGggb3RoZXIgY2hhcmFjdGVycyBsaWtlIFs+XSB3aWxsIHJlbWFpbi5cIixcbiAgICAgICAgICAgIGNsczogXCJzZXR0aW5nLWl0ZW0tZGVzY3JpcHRpb25cIixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpLnNldEhlYWRpbmcoKS5zZXROYW1lKFwiTnVtYmVyZWQgbGlzdHNcIik7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZShcIkF1dG8tcmVudW1iZXIgb24gY2hhbmdlc1wiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJBdXRvbWF0aWNhbGx5IHNvcnQgbnVtYmVyZWQgbGlzdHMgYXMgY2hhbmdlcyBhcmUgbWFkZS5cIilcbiAgICAgICAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT5cbiAgICAgICAgICAgICAgICB0b2dnbGUuc2V0VmFsdWUodGhpcy5zZXR0aW5nc01hbmFnZXIuZ2V0TGl2ZU51bWJlcmluZ1VwZGF0ZSgpKS5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nc01hbmFnZXIuc2V0TGl2ZU51bWJlcmluZ1VwZGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc21hcnRQYXN0aW5nVG9nZ2xlRWwuY2xhc3NMaXN0LmFkZChcInNtYXJ0LXBhc3RlLXRvZ2dsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNtYXJ0UGFzdGluZ1RvZ2dsZUVsLmNsYXNzTGlzdC5yZW1vdmUoXCJzbWFydC1wYXN0ZS10b2dnbGUtZGlzYWJsZWRcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbWFydFBhc3RpbmdUb2dnbGVFbC5jbGFzc0xpc3QucmVtb3ZlKFwic21hcnQtcGFzdGUtdG9nZ2xlXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc21hcnRQYXN0aW5nVG9nZ2xlRWwuY2xhc3NMaXN0LmFkZChcInNtYXJ0LXBhc3RlLXRvZ2dsZS1kaXNhYmxlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIGNvbnN0IHNtYXJ0UGFzdGluZ1NldHRpbmcgPSBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgICAgICAgIC5zZXROYW1lKFwiU21hcnQgcGFzdGluZ1wiKVxuICAgICAgICAgICAgLnNldERlc2MoXCJQYXN0aW5nIGtlZXBzIHRoZSBzZXF1ZW5jaW5nIGNvbnNpc3RlbnQgd2l0aCB0aGUgb3JpZ2luYWwgbnVtYmVyZWQgbGlzdC5cIilcbiAgICAgICAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT5cbiAgICAgICAgICAgICAgICB0b2dnbGUuc2V0VmFsdWUodGhpcy5zZXR0aW5nc01hbmFnZXIuZ2V0U21hcnRQYXN0aW5nKCkpLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzTWFuYWdlci5zZXRTbWFydFBhc3RpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBzbWFydFBhc3RpbmdUb2dnbGVFbCA9IHNtYXJ0UGFzdGluZ1NldHRpbmcuc2V0dGluZ0VsO1xuXG4gICAgICAgIGNvbnN0IGlzTGl2ZU51bWJlcmluZ1VwZGF0ZUVuYWJsZWQgPSB0aGlzLnNldHRpbmdzTWFuYWdlci5nZXRMaXZlTnVtYmVyaW5nVXBkYXRlKCk7XG4gICAgICAgIGlmIChpc0xpdmVOdW1iZXJpbmdVcGRhdGVFbmFibGVkKSB7XG4gICAgICAgICAgICBzbWFydFBhc3RpbmdUb2dnbGVFbC5jbGFzc0xpc3QuYWRkKFwic21hcnQtcGFzdGUtdG9nZ2xlXCIpO1xuICAgICAgICAgICAgc21hcnRQYXN0aW5nVG9nZ2xlRWwuY2xhc3NMaXN0LnJlbW92ZShcInNtYXJ0LXBhc3RlLXRvZ2dsZS1kaXNhYmxlZFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNtYXJ0UGFzdGluZ1RvZ2dsZUVsLmNsYXNzTGlzdC5hZGQoXCJzbWFydC1wYXN0ZS10b2dnbGUtZGlzYWJsZWRcIik7XG4gICAgICAgICAgICBzbWFydFBhc3RpbmdUb2dnbGVFbC5jbGFzc0xpc3QucmVtb3ZlKFwic21hcnQtcGFzdGUtdG9nZ2xlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZShcIlN0YXJ0IG51bWJlcmluZyBmcm9tIDFcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiV2hldGhlciBsaXN0cyBhbHdheXMgc3RhcnQgZnJvbSAxIG9yIHByZXNlcnZlIHRoZWlyIG9yaWdpbmFsIHN0YXJ0aW5nIG51bWJlcnMuXCIpXG4gICAgICAgICAgICAuYWRkVG9nZ2xlKCh0b2dnbGUpID0+XG4gICAgICAgICAgICAgICAgdG9nZ2xlLnNldFZhbHVlKHRoaXMuc2V0dGluZ3NNYW5hZ2VyLmdldFN0YXJ0c0Zyb21PbmUoKSkub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NNYW5hZ2VyLnNldFN0YXJ0c0Zyb21PbmUodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICB9XG59XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFBQUEsbUJBQTZEOzs7QUNBN0Qsc0JBQXdEOzs7QUNFeEQsSUFBTSwrQkFBb0Q7QUFBQSxFQUN0RCxZQUFZO0FBQUEsRUFDWixjQUFjO0FBQUEsRUFDZCxlQUFlO0FBQ25CO0FBRUEsSUFBTSw2QkFBZ0Q7QUFBQSxFQUNsRCxZQUFZO0FBQUEsRUFDWixzQkFBc0I7QUFBQSxFQUN0QixrQkFBa0I7QUFBQSxFQUNsQixlQUFlO0FBQ25CO0FBRU8sSUFBTSxtQkFBbUM7QUFBQSxFQUM1QyxhQUFhO0FBQUEsRUFDYixXQUFXO0FBQUEsRUFDWCxZQUFZO0FBQ2hCO0FBR0EsSUFBcUIsa0JBQXJCLE1BQXFCLGlCQUFnQjtBQUFBLEVBSXpCLGNBQWM7QUFDbEIsU0FBSyxXQUFXO0FBQUEsRUFDcEI7QUFBQSxFQUVBLE9BQWMsY0FBK0I7QUFDekMsUUFBSSxDQUFDLGlCQUFnQixVQUFVO0FBQzNCLHVCQUFnQixXQUFXLElBQUksaUJBQWdCO0FBQUEsSUFDbkQ7QUFFQSxXQUFPLGlCQUFnQjtBQUFBLEVBQzNCO0FBQUEsRUFF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LFlBQVk7QUFDcEQsVUFBTSxXQUFXLE9BQU8sT0FBTyxDQUFDLEdBQUcsa0JBQWtCLE1BQU0sS0FBSyxTQUFTLENBQUM7QUFDMUUsb0JBQWdCLFlBQVksUUFBUTtBQUFBLEVBQ3hDO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDakIsVUFBTSxrQkFBa0IsZ0JBQWdCLFlBQVk7QUFDcEQsVUFBTSxLQUFLLFNBQVMsZ0JBQWdCLFlBQVksQ0FBQztBQUFBLEVBQ3JEO0FBQUEsRUFFQSxnQkFBNEI7QUFDeEIsV0FBTyxLQUFLO0FBQUEsRUFDaEI7QUFBQSxFQUVBLHFCQUFxQixRQUFnQixhQUE2QixlQUFxQztBQUNuRyxRQUFJLE9BQU8sa0JBQWtCLEtBQUssQ0FBQyxlQUFlO0FBQzlDO0FBQUEsSUFDSjtBQUtBLFFBQUk7QUFDSixRQUFJLFlBQVksT0FBTyxjQUFjLFNBQVMsY0FBYyxTQUFTLFlBQVksTUFBTTtBQUNuRixvQkFBYztBQUFBLFFBQ1YsTUFBTSxZQUFZO0FBQUEsUUFDbEIsSUFBSSxZQUFZO0FBQUEsTUFDcEI7QUFBQSxJQUNKLE9BQU87QUFDSCxZQUFNLE9BQU8sT0FBTyxRQUFRLFlBQVksSUFBSTtBQUM1QyxvQkFBYztBQUFBLFFBQ1YsTUFBTSxZQUFZO0FBQUEsUUFDbEIsSUFBSSxLQUFLO0FBQUE7QUFBQSxNQUNiO0FBQUEsSUFDSjtBQUNBLFdBQU8sVUFBVSxXQUFXO0FBQUEsRUFDaEM7QUFBQSxFQUVBLGFBQWEsUUFBcUQ7QUFDOUQsVUFBTSxXQUFXLEtBQUssZUFBZTtBQUVyQyxRQUFJLEtBQUssc0JBQXNCLFFBQVc7QUFDdEMsWUFBTSxRQUFRLEtBQUs7QUFDbkIsV0FBSyxvQkFBb0I7QUFFekIsVUFBSSxDQUFDLFVBQVU7QUFDWCxlQUFPLEVBQUUsT0FBTyxTQUFTLE1BQU07QUFBQSxNQUNuQztBQUNBLGFBQU8sRUFBRSxNQUFNO0FBQUEsSUFDbkI7QUFFQSxVQUFNLFlBQVksT0FBTyxlQUFlLEVBQUUsQ0FBQztBQUMzQyxXQUFPLEVBQUUsT0FBTyxLQUFLLElBQUksVUFBVSxPQUFPLE1BQU0sVUFBVSxLQUFLLElBQUksRUFBRTtBQUFBLEVBQ3pFO0FBQUEsRUFFQSxpQkFBMEI7QUFDdEIsVUFBTSxhQUFhLEtBQUssSUFBSSxVQUFVLG9CQUFvQiw2QkFBWTtBQUN0RSxRQUFJLFlBQVk7QUFFWixZQUFNLGFBQWEsV0FBVyxPQUFPO0FBQ3JDLFlBQU0sTUFBTSxXQUFXLE1BQU0sVUFBVSxLQUFLO0FBQzVDLFlBQU0sU0FBUyxXQUFXLFlBQVksR0FBRztBQUN6QyxVQUFJLFFBQVE7QUFDUixjQUFNLGFBQWEsV0FBVyxJQUFJLHNCQUFzQjtBQUN4RCxlQUFPLE9BQU8sT0FBTyxXQUFXLE9BQU8sT0FBTyxVQUFVLFdBQVc7QUFBQSxNQUN2RTtBQUFBLElBQ0o7QUFFQSxXQUFPO0FBQUEsRUFDWDtBQUNKOyIsCiAgIm5hbWVzIjogWyJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImkiLCAiaW1wb3J0X29ic2lkaWFuIl0KfQo=
