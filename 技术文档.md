# 坐标系扩展系统 - 技术文档

## 1. 坐标系定义

### 1.1 直角坐标系（Cartesian Coordinate System）
**Unity使用左手坐标系：**
- **原点**：可自定义，默认为(0, 0, 0)
- **轴方向**：
  - X轴：指向右方（Right）
  - Y轴：指向上方（Up）
  - Z轴：指向前方（Forward）
- **单位长度**：Unity单位（米）
- **表示**：点的位置表示为 P(x, y, z)

### 1.2 柱坐标系（Cylindrical Coordinate System）
- **原点**：与直角坐标系原点对应
- **轴方向**：
  - **径向(r)**：从Z轴到点的水平距离（r ≥ 0）
  - **角向(θ)**：从X轴正方向逆时针旋转的角度（弧度制，0 ≤ θ < 2π）
  - **高度(h)**：沿Y轴的高度（-∞ < h < +∞）
- **单位长度**：
  - r: Unity单位
  - θ: 弧度
  - h: Unity单位
- **表示**：点的位置表示为 P(r, θ, h)

**注意**：在柱坐标系中：
- 当θ变化时，物体会绕Y轴旋转
- 物体的"前方"可以定义为切线方向（θ增加的方向）
- 径向移动会改变r，切向移动会改变θ

### 1.3 球坐标系（Spherical Coordinate System）
- **原点**：与直角坐标系原点对应
- **轴方向**：
  - **半径(ρ)**：从原点到点的距离（ρ ≥ 0）
  - **方位角(θ)**：投影到XZ平面后，从X轴正方向逆时针旋转的角度（0 ≤ θ < 2π）
  - **极角(φ)**：从Y轴正方向向下到点的连线的角度（0 ≤ φ ≤ π）
- **单位长度**：
  - ρ: Unity单位
  - θ: 弧度
  - φ: 弧度
- **表示**：点的位置表示为 P(ρ, θ, φ)

**注意**：在球坐标系中：
- φ = 0 时，点在Y轴正方向
- φ = π/2 时，点在XZ平面上
- φ = π 时，点在Y轴负方向

## 2. 坐标转换公式

### 2.1 直角坐标 → 柱坐标
```
r = sqrt(x² + z²)
θ = atan2(z, x)
h = y
```

### 2.2 柱坐标 → 直角坐标
```
x = r * cos(θ)
y = h
z = r * sin(θ)
```

### 2.3 直角坐标 → 球坐标
```
ρ = sqrt(x² + y² + z²)
θ = atan2(z, x)
φ = acos(y / ρ)  // 当 ρ ≠ 0
```

### 2.4 球坐标 → 直角坐标
```
x = ρ * sin(φ) * cos(θ)
y = ρ * cos(φ)
z = ρ * sin(φ) * sin(θ)
```

### 2.5 柱坐标 → 球坐标
```
ρ = sqrt(r² + h²)
θ = θ  // 保持不变
φ = atan2(r, h)
```

### 2.6 球坐标 → 柱坐标
```
r = ρ * sin(φ)
θ = θ  // 保持不变
h = ρ * cos(φ)
```

## 3. 方向向量的变换

### 3.1 柱坐标系的基向量
在位置(r, θ, h)处：
- **径向单位向量** e_r = (cos(θ), 0, sin(θ))
- **切向单位向量** e_θ = (-sin(θ), 0, cos(θ))
- **高度单位向量** e_h = (0, 1, 0)

### 3.2 球坐标系的基向量
在位置(ρ, θ, φ)处：
- **径向单位向量** e_ρ = (sin(φ)cos(θ), cos(φ), sin(φ)sin(θ))
- **极向单位向量** e_φ = (cos(φ)cos(θ), -sin(φ), cos(φ)sin(θ))
- **方位向单位向量** e_θ = (-sin(θ), 0, cos(θ))

### 3.3 方向向量转换
如果在柱坐标系中有方向向量 (v_r, v_θ, v_h)：
```
向量在直角坐标系中 = v_r * e_r + v_θ * e_θ + v_h * e_h
```

同理适用于球坐标系。

## 4. 移动、旋转、缩放的数学表示

### 4.1 直角坐标系
- **移动**：P' = P + ΔP，其中 ΔP = (Δx, Δy, Δz)
- **旋转**：使用旋转矩阵或四元数
- **缩放**：P' = S · P，其中 S = (sx, sy, sz)

### 4.2 柱坐标系
- **移动**：
  - 径向移动：r' = r + Δr
  - 切向移动：θ' = θ + Δθ
  - 高度移动：h' = h + Δh
  - **朝向变化**：
    - 沿切向移动时，物体应旋转以保持切线方向
    - 新的前方向 = e_θ（在当前位置）

- **旋转**：
  - 绕Y轴旋转影响θ
  - 局部旋转需要基于当前基向量

- **缩放**：
  - 径向缩放影响r
  - 高度缩放影响h
  - 切向缩放可以影响半径（视具体需求）

### 4.3 球坐标系
- **移动**：
  - 径向移动：ρ' = ρ + Δρ
  - 极向移动：φ' = φ + Δφ
  - 方位移动：θ' = θ + Δθ
  - **朝向变化**：
    - 移动时物体朝向应随球面切线方向变化
    - 可以选择e_φ或e_θ作为前方向

- **旋转**：
  - 基于球坐标的局部基向量

- **缩放**：
  - 径向缩放影响ρ
  - 其他维度缩放需要特殊处理

## 5. 类设计

### 5.1 核心类结构

```
CoordinateSystemBase (抽象基类)
├── CartesianCoordinateSystem (直角坐标系)
├── CylindricalCoordinateSystem (柱坐标系)
└── SphericalCoordinateSystem (球坐标系)

CoordinateObject (坐标对象)
├── 存储在特定坐标系中的位置
├── 存储旋转和缩放信息
└── 提供转换到世界坐标的方法

CoordinateTransformer (坐标转换器)
└── 提供各坐标系之间的转换方法
```

### 5.2 类详细设计

#### CoordinateSystemBase
```csharp
abstract class CoordinateSystemBase
{
    // 属性
    + Vector3 Origin { get; set; }              // 坐标系原点（世界坐标）
    + Quaternion Orientation { get; set; }      // 坐标系朝向
    + CoordinateSystemType Type { get; }        // 坐标系类型

    // 抽象方法 - 子类必须实现
    + abstract Vector3 ToWorldPosition(Vector3 localCoords)
    + abstract Vector3 FromWorldPosition(Vector3 worldPos)
    + abstract Vector3 GetForwardDirection(Vector3 localCoords)
    + abstract Vector3 GetUpDirection(Vector3 localCoords)
    + abstract Vector3 GetRightDirection(Vector3 localCoords)
    + abstract Quaternion GetRotation(Vector3 localCoords, Quaternion localRotation)

    // 移动方法
    + abstract Vector3 Move(Vector3 currentCoords, Vector3 movement)
    + abstract Quaternion UpdateRotationAfterMovement(Vector3 oldCoords, Vector3 newCoords, Quaternion currentRotation)
}
```

#### CartesianCoordinateSystem
```csharp
class CartesianCoordinateSystem : CoordinateSystemBase
{
    // 实现基类的所有抽象方法
    // 直角坐标系比较简单，大多数直接映射
}
```

#### CylindricalCoordinateSystem
```csharp
class CylindricalCoordinateSystem : CoordinateSystemBase
{
    // 属性
    + Vector3 AxisDirection { get; set; }  // 中心轴方向（默认为Y轴）

    // 坐标表示: (r, θ, h)
    // 实现所有坐标转换和方向计算方法

    // 特殊方法
    + Vector3 GetRadialDirection(Vector3 cylindricalCoords)
    + Vector3 GetTangentialDirection(Vector3 cylindricalCoords)
}
```

#### SphericalCoordinateSystem
```csharp
class SphericalCoordinateSystem : CoordinateSystemBase
{
    // 坐标表示: (ρ, θ, φ)
    // 实现所有坐标转换和方向计算方法

    // 特殊方法
    + Vector3 GetRadialDirection(Vector3 sphericalCoords)
    + Vector3 GetPolarDirection(Vector3 sphericalCoords)
    + Vector3 GetAzimuthalDirection(Vector3 sphericalCoords)
}
```

#### CoordinateObject
```csharp
class CoordinateObject
{
    // 属性
    + CoordinateSystemBase CoordinateSystem { get; set; }
    + Vector3 LocalPosition { get; set; }      // 在自定义坐标系中的位置
    + Quaternion LocalRotation { get; set; }   // 在自定义坐标系中的旋转
    + Vector3 LocalScale { get; set; }         // 在自定义坐标系中的缩放

    // 世界坐标属性（计算得出）
    + Vector3 WorldPosition { get; }
    + Quaternion WorldRotation { get; }
    + Vector3 WorldScale { get; }

    // 方法
    + void Move(Vector3 movement)              // 在当前坐标系中移动
    + void Rotate(Quaternion rotation)         // 在当前坐标系中旋转
    + void Scale(Vector3 scale)                // 在当前坐标系中缩放
    + void SwitchCoordinateSystem(CoordinateSystemBase newSystem)  // 切换坐标系
    + Vector3 GetForwardDirection()            // 获取前方向
}
```

#### CoordinateTransformer
```csharp
static class CoordinateTransformer
{
    // 直角 ↔ 柱
    + static Vector3 CartesianToCylindrical(Vector3 cartesian)
    + static Vector3 CylindricalToCartesian(Vector3 cylindrical)

    // 直角 ↔ 球
    + static Vector3 CartesianToSpherical(Vector3 cartesian)
    + static Vector3 SphericalToCartesian(Vector3 spherical)

    // 柱 ↔ 球
    + static Vector3 CylindricalToSpherical(Vector3 cylindrical)
    + static Vector3 SphericalToCylindrical(Vector3 spherical)

    // 方向向量转换
    + static Vector3 TransformDirection(Vector3 direction, Vector3 position,
                                       CoordinateSystemBase from, CoordinateSystemBase to)
}
```

### 5.3 辅助类

#### Vector3 结构（纯C#实现，不依赖Unity）
```csharp
struct Vector3
{
    + float x, y, z
    + Vector3(float x, float y, float z)
    + static Vector3 operator +(Vector3 a, Vector3 b)
    + static Vector3 operator -(Vector3 a, Vector3 b)
    + static Vector3 operator *(Vector3 a, float f)
    + static float Dot(Vector3 a, Vector3 b)
    + static Vector3 Cross(Vector3 a, Vector3 b)
    + float Magnitude { get; }
    + Vector3 Normalized { get; }
    + static float Distance(Vector3 a, Vector3 b)
}
```

#### Quaternion 结构（纯C#实现）
```csharp
struct Quaternion
{
    + float x, y, z, w
    + Quaternion(float x, float y, float z, float w)
    + static Quaternion operator *(Quaternion a, Quaternion b)
    + static Vector3 operator *(Quaternion q, Vector3 v)
    + static Quaternion Euler(float x, float y, float z)
    + static Quaternion LookRotation(Vector3 forward, Vector3 up)
    + static Quaternion FromToRotation(Vector3 from, Vector3 to)
    + Vector3 eulerAngles { get; }
}
```

## 6. 方法列表总结

### 6.1 坐标转换方法
- `ToWorldPosition()` - 本地坐标→世界坐标
- `FromWorldPosition()` - 世界坐标→本地坐标
- `CartesianToCylindrical()` - 直角→柱
- `CylindricalToCartesian()` - 柱→直角
- `CartesianToSpherical()` - 直角→球
- `SphericalToCartesian()` - 球→直角
- `CylindricalToSpherical()` - 柱→球
- `SphericalToCylindrical()` - 球→柱

### 6.2 方向计算方法
- `GetForwardDirection()` - 获取前方向
- `GetUpDirection()` - 获取上方向
- `GetRightDirection()` - 获取右方向
- `GetRadialDirection()` - 获取径向（柱/球坐标系）
- `GetTangentialDirection()` - 获取切向（柱坐标系）
- `GetPolarDirection()` - 获取极向（球坐标系）
- `GetAzimuthalDirection()` - 获取方位向（球坐标系）

### 6.3 变换方法
- `Move()` - 在坐标系中移动
- `Rotate()` - 在坐标系中旋转
- `Scale()` - 在坐标系中缩放
- `UpdateRotationAfterMovement()` - 移动后更新旋转
- `SwitchCoordinateSystem()` - 切换坐标系

### 6.4 辅助方法
- `GetRotation()` - 根据本地坐标和旋转计算世界旋转
- `TransformDirection()` - 方向向量在不同坐标系间转换

## 7. 关键算法说明

### 7.1 柱坐标系移动中的朝向变化
当物体在柱坐标系中沿切向移动时：
```
1. 计算移动前的切向：tangent_old = (-sin(θ_old), 0, cos(θ_old))
2. 移动到新位置：θ_new = θ_old + Δθ
3. 计算移动后的切向：tangent_new = (-sin(θ_new), 0, cos(θ_new))
4. 计算旋转增量：deltaRotation = Quaternion.FromToRotation(tangent_old, tangent_new)
5. 更新物体旋转：rotation_new = deltaRotation * rotation_old
```

### 7.2 球坐标系移动中的朝向变化
当物体在球坐标系中移动时，可以选择两种朝向策略：
1. **径向朝向**：始终面向原点外侧（e_ρ方向）
2. **切线朝向**：沿运动方向（e_φ或e_θ方向）

实现时需要根据移动方向选择合适的策略。

### 7.3 坐标系切换算法
```
1. 获取物体在原坐标系中的世界位置和旋转
2. 将世界位置转换到新坐标系的本地坐标
3. 计算新坐标系中物体应有的朝向
4. 更新物体的本地坐标和旋转
```

## 8. 性能优化策略

### 8.1 脏标志（Dirty Flag）
```csharp
class CoordinateObject
{
    private bool _isDirty = false;
    private Vector3 _cachedWorldPosition;

    public Vector3 WorldPosition
    {
        get
        {
            if (_isDirty)
            {
                _cachedWorldPosition = CalculateWorldPosition();
                _isDirty = false;
            }
            return _cachedWorldPosition;
        }
    }

    public void SetLocalPosition(Vector3 pos)
    {
        if (_localPosition != pos)
        {
            _localPosition = pos;
            _isDirty = true;
        }
    }
}
```

### 8.2 批量更新
当多个对象属于同一坐标系时，可以：
1. 收集所有需要更新的对象
2. 一次性计算坐标系的变换矩阵
3. 批量应用到所有对象

### 8.3 增量更新
只在坐标系参数或对象位置实际改变时才重新计算。

## 9. 测试用例设计

### 9.1 单元测试
- 测试各种坐标转换的正确性（往返转换误差<0.0001）
- 测试边界条件（r=0, θ=0/2π, φ=0/π等）
- 测试方向向量计算的正交性
- 测试移动和旋转的正确性

### 9.2 集成测试
- 测试坐标系切换后位置保持不变
- 测试连续移动的累积误差
- 测试复杂场景（多个坐标系，多个对象）

## 10. Unity适配设计（Phase 3预览）

### 10.1 MonoBehaviour脚本
- `CoordinateSystemBehaviour`：挂载在父物体上，定义坐标系
- `CoordinateObjectBehaviour`：挂载在子物体上，管理物体在坐标系中的位置

### 10.2 双向同步机制
```csharp
// 方案1：使用属性+脏标志
private Vector3 _customPosition;
private bool _syncingFromTransform = false;

void Update()
{
    if (!_syncingFromTransform && transform.hasChanged)
    {
        // Transform改变，更新自定义坐标
        _customPosition = CoordinateSystem.FromWorldPosition(transform.position);
        transform.hasChanged = false;
    }
}

public void SetCustomPosition(Vector3 pos)
{
    _customPosition = pos;
    _syncingFromTransform = true;
    transform.position = CoordinateSystem.ToWorldPosition(pos);
    _syncingFromTransform = false;
}
```

### 10.3 编辑器Gizmo设计
- 在Scene视图中绘制自定义坐标轴
- 使用Handles.PositionHandle创建自定义移动手柄
- 使用Handles.RotationHandle创建自定义旋转手柄
- 使用Handles.ScaleHandle创建自定义缩放手柄
- 支持撤销操作（Undo.RecordObject）

---

## 总结

本技术文档详细说明了三种坐标系（直角、柱、球）的数学定义、转换公式、以及在Unity中实现的类设计。接下来将基于此文档进行纯C#实现（Phase 2），然后进行Unity适配（Phase 3）。
